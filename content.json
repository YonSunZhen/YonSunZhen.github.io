{"meta":{"title":"码上就来","subtitle":null,"description":null,"author":"皮皮虾","url":"http://yonsunzhen.github.io","root":"/"},"pages":[],"posts":[{"title":"json-go-ts VS Code插件开发","slug":"json-go-ts VS Code插件开发","date":"2021-08-02T06:16:10.000Z","updated":"2023-05-18T14:27:34.597Z","comments":true,"path":"2021/08/02/json-go-ts VS Code插件开发/","link":"","permalink":"http://yonsunzhen.github.io/2021/08/02/json-go-ts%20VS%20Code%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","excerpt":"","text":"背景 项目中需要一份json配置文件，这份配置文件的某些字段是依据另外的一个typescrip文件export出来的字段，为了降低编码过程中造成的字段名出错的机率。 因此，考虑开发一个插件用于： json文件中自动补全function name jaon文件到typescript文件的自定义跳转 json文件中错误波浪线智能提示（当typescript文件没有export该字段时显示波浪线） 插件效果： 实现 思路：定义两个插件变量（可根据实际情况自己在插件设置里面配置） fileName：用于识别文件名关键字 – 默认为index filePath：以json文件为参照，index typescript文件的相对路径，用于获取ts文件 – 默认为./src/index 关键实现：使用@babel/parser、@babel/traverse将ts文件转化AST，这样才能获取到ts文件中export出来的function name 项目源码 自动补全 思路： 获取ts文件中export出来的function列表 监听VS Code中光标处输入的字符，当输入index.时，弹出自动补全面板，此时自动补全面板中的内容就是ts文件中export出来的所有function列表 关键代码实现： 1234567891011121314export function provideCompletionItems(document, position, token, context) &#123; const _filePath = getFilePath(document, filePath); const _fnData = getFnFromTsFile(`$&#123;_filePath&#125;.ts`); const linePrefix = document.lineAt(position).text.substr(0, position.character); if (!linePrefix.endsWith(`&quot;$&#123;fileName&#125;.`)) &#123; return undefined; &#125; let myitem = (text: string) =&gt; &#123; let item = new vscode.CompletionItem(text, vscode.CompletionItemKind.Function); item.range = new vscode.Range(position, position); return item; &#125;; return _fnData.map(_fnItem =&gt; myitem(_fnItem.fnName));&#125; 跳转到定义 思路： 获取ts文件中export出来的function列表，包括每个function对应的loc（即function在编辑器中所处的位置信息），这就是前面我们为什么要将ts文件转化为AST的重要原因，后面实现代码跳转需要用到这些位置信息 获取光标处所在的function并跳转到对应ts文件中的对应位置 关键代码实现： 123456789101112131415161718192021222324252627282930313233343536export function provideDefinition(document: vscode.TextDocument, position: vscode.Position, token) &#123; const _filePath = getFilePath(document, filePath); const _fnData = getFnFromTsFile(`$&#123;_filePath&#125;.ts`); const _wordRangePosition = document.getWordRangeAtPosition(position); const word = document.getText(_wordRangePosition); // 获取当前光标输入字符 const _reg = new RegExp(`&quot;$&#123;fileName&#125;\\..*&quot;`); if (_reg.test(word)) &#123; // const _fnName = word.replace(/&quot;index\\.|&quot;/g, &#x27;&#x27;); const _fnName = word.replace(new RegExp(`&quot;$&#123;fileName&#125;\\.|&quot;`, &#x27;g&#x27;), &#x27;&#x27;); if(_fnData.map(_fnItem =&gt; _fnItem.fnName).includes(_fnName)) &#123; const filePath = `$&#123;_filePath&#125;.ts`; for(const _fnItem of _fnData) &#123; if(_fnItem.fnName === _fnName) &#123; const tmpPath = `file:///$&#123;filePath&#125;`; // TODO: 踩坑记录 必须 /// if (fs.existsSync(filePath)) &#123; const _targetUri = vscode.Uri.parse(tmpPath); // TODO: 踩坑记录 使用parse const _targetPosition = new vscode.Position(_fnItem.loc.start.line, _fnItem.loc.start.column); const _targetRange = new vscode.Range(_targetPosition, _targetPosition); const _fileNameLen = (fileName as string).length || 0; // 当按住ctrl时，编辑器默认会将连在一块的字符都显示出来下划线 这时候如果想指定哪些字符需要显示下划线需要配置以下的originSelectionRange const _orgSelectionStartPosition = new vscode.Position(_wordRangePosition.start.line, _wordRangePosition.start.character + _fileNameLen + 2); const _orgSelectionEndPosition = new vscode.Position(_wordRangePosition.end.line, _wordRangePosition.end.character - 1); const _originSelectionRange = new vscode.Range(_orgSelectionStartPosition, _orgSelectionEndPosition); const _locationLink: vscode.LocationLink = &#123; originSelectionRange: _originSelectionRange, targetUri: _targetUri, targetRange: _targetRange &#125;; return [_locationLink]; // return new vscode.Location(vscode.Uri.parse(tmpPath), new vscode.Position(_fnItem.loc.start.line, _fnItem.loc.start.column)); &#125; &#125; &#125; &#125; &#125;&#125; 智能诊断&amp;提示 这个功能的主要对象是json文件，因此我们需要获取到json文件中所有的字段，包括每个字段所处的位置信息（为了后面显示波浪线），这时候我们可能会想到说，将json文件转化为AST，思路是正确的，但是前面说的@babel/traverse只能用来转化js或ts文件，并不支持json文件的转化 幸好别人已经有写过类似的轮子了，json-to-ast出场，json-to-ast可以将json文件转化为AST，感谢开源。 另外：在VS Code中智能诊断使用createDiagnosticCollection这个API来实现的，切记。 关键代码实现： 12345678910111213// 智能诊断 波浪线提示const collection = vscode.languages.createDiagnosticCollection(&#x27;testFnName&#x27;);if (vscode.window.activeTextEditor) &#123; collection.clear(); updateDiagnostics(vscode.window.activeTextEditor.document, collection);&#125;// 使用onDidChangeTextDocument监听编辑文档事件context.subscriptions.push(vscode.workspace.onDidChangeTextDocument(editor =&gt; &#123; if (editor) &#123; collection.clear(); updateDiagnostics(editor.document, collection); &#125;&#125;)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344export function updateDiagnostics(document: vscode.TextDocument, collection: vscode.DiagnosticCollection): void &#123; const _text = document.getText(); const _jsonAst = jsonToAst(_text) as jsonToAst.ObjectNode; const _errorText: JsonTextInfo[] = []; const _filePath = getFilePath(document, filePath); const _fnData = getFnFromTsFile(`$&#123;_filePath&#125;.ts`); const recursiveJsonAst = (astArr: any[]) =&gt; &#123; astArr.forEach((jsonAstItem) =&gt; &#123; const _value = jsonAstItem?.value || jsonAstItem?.children; if(_value.children) &#123; recursiveJsonAst(_value.children); &#125; else if(Array.isArray(_value)) &#123; recursiveJsonAst(_value); &#125; else &#123; const _textValue = _value.value; const _reg = new RegExp(`$&#123;fileName&#125;\\..*`, &#x27;g&#x27;); if(_reg.test(_textValue)) &#123; const _fnVal = _textValue.replace(new RegExp(`$&#123;fileName&#125;\\.`, &#x27;g&#x27;), &#x27;&#x27;); if(!_fnData.map((_fnItem =&gt; _fnItem.fnName)).includes(_fnVal)) &#123; _errorText.push(&#123; value: _fnVal, loc: _value.loc &#125;); &#125; &#125; &#125; &#125;); &#125;; recursiveJsonAst(_jsonAst.children); const _diagCollection = []; _errorText.forEach(_errTextItem =&gt; &#123; const _start = _errTextItem.loc.start; const _end = _errTextItem.loc.end; const _fileNameLen = (fileName as string).length || 0; const _startPosition = new vscode.Position(_start.line - 1, _start.column + _fileNameLen + 1); const _endPosition = new vscode.Position(_end.line - 1, _end.column - 2); _diagCollection.push(&#123; message: `Function $&#123;_errTextItem.value&#125; does not exist`, range: new vscode.Range(_startPosition, _endPosition), severity: vscode.DiagnosticSeverity.Error, &#125;); &#125;); collection.set(document.uri, _diagCollection);&#125; 一些踩坑 发布插件时执行vsce publish时报错ERROR Failed request: (401)，生成的personal access token权限弄错了，应该选Full access 发布插件时报错：ERROR Make sure to edit the README.md file before you package or publish your extension – 修改一下工程里面的README.md文件（原来的文件删除&amp;重写） 使用地址创建publisher账号一直不成功 – 网络被限制了（科学上网真香） 插件在本地开发环境下可以运行，发布到线上没有响应（也没有报错） 经过排查，项目中使用了一些npm库，但是发布插件时使用了tsc来编译，这种情况下node_modules里面一些npm库的代码是没有被编译进去的。需要引入webpack来进行打包&amp;编译 参考 json文件中自动补全面板不弹出 VS Code插件开发全攻略 VS Code Document Some demo","categories":[{"name":"其他","slug":"其他","permalink":"http://yonsunzhen.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"谈谈跨域那些事","slug":"谈谈跨域那些事","date":"2021-07-30T06:05:30.000Z","updated":"2023-05-18T14:27:34.599Z","comments":true,"path":"2021/07/30/谈谈跨域那些事/","link":"","permalink":"http://yonsunzhen.github.io/2021/07/30/%E8%B0%88%E8%B0%88%E8%B7%A8%E5%9F%9F%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"浏览器中的HTTP请求 XMLHttpRequest XHR对象用于与服务器交互。通过XMLHttpRequest可以在不刷新页面的情况下请求特定URL，获取数据。 XMLHttpRequest在AJAX编程中被大量使用。 MDN文档 Fetch Fetch API提供了一个获取资源的接口（包括跨域请求） MDN文档 AJAX Asynchronous JavaScript And XML，是一种使用XMLHttpRequest技术构建更复杂，动态的网页的编程实践。大部分的ajax其实就是对XMLHttpRequest的相关API进行封装，使其使用起来更加方便。 MDN文档 跨域 跨域，顾名思义，跨越区域。大概意思为访问的网站请求非同源资源。 当前页面URL 被请求资源URL 跨域 原因 http://www.test.com http://www.test.com/api/users 否 同源(协议 域名 端口号相同) http://www.test.com https://www.test.com/api/users 是 协议不同(http/https) http://www.test.com http://www.baidu.com/api/users 是 主域名不同(test/baidu) http://www.test.com http://blog.test.com/api/users 是 子域名不同(www/blog) http://www.test.com:8080 http://www.test.com:7070/api/user 是 端口号不同(8080/7070) 为什么会有跨域 遇事先问为什么。所以，浏览器为什么要设置跨域的限制，然后我们后面还要费心费力地消除跨域的限制。 为了web生态的安全。看一个例子： 假设浏览器里面的代码可以随意访问第三方的数据（非同源），那么你可以让你的代码定时轮询访问一个非同源的网页，假设某个时刻恰好有10万人在访问你的网页，那这个第三方的网页每秒就要承受10万的并发量，这样网络中大量的带宽就会被这样白白的浪费掉，整个web生态将会混乱无比。 当访问的网站需要请求非同源资源时，浏览器将拒绝这些非同源请求。在这种情况下，我们需要解决浏览器跨域时拒绝请求非同源资源的限制。 当浏览器出现跨域时，那就不可避免的引出两个关键的概念了。简单请求和非简单请求。 当跨域产生时，非简单请求会在真正向服务端发送请求前进行预检请求（OPTIONS）。 简单请求 1、条件定义：若请求满足以下所有的条件，则请求可视为简单请求。 使用下列方法之一： GET HEAD POST 请求首部字段不得超出以下集合 Accept Accept-Language Content-Language Conent-Type：text/plain || multipart/form-data || application/x-www-form-urlencoded DPR Downlink Save-Data Viewport-Width Width 请求中的任意XMLHttpRequestUpload 对象均没有注册任何事件监听器 请求中没有使用 ReadableStream 对象 非简单请求 1、条件定义：若请求满足下列任一条件时，即应首先发送预检请求（options）。 使用了下面的任一方法： PUT DELETE CONNECT OPTIONS TRACE PATCH 设置了额外的请求首部字段（除去以下集合中的） Accept Accept-Language Content-Language Conent-Type：text/plain || multipart/form-data || application/x-www-form-urlencoded DPR Downlink Save-Data Viewport-Width Width 请求中的XMLHttpRequestUpload 对象注册了任意多个事件监听器 请求中使用了ReadableStream对象 解决跨域的方案 jsonp JSON with Padding，是JSON的一种使用模式，可以让网页从别的网域获取资料。由于同源策略，一般来说位于server1.example.com的网页无法与不是server1.example.com的服务器沟通，而HTML的&lt;script&gt;元素是一个例外。利用&lt;script&gt;元素的这个开放策略，网页就可以实现跨域获取后端接口数据。 由于使用script标签的src属性，因此只支持get方法。 当使用JSONP这种方案时，前后端都要有相对应的写法。 大致流程就是，前端通过&lt;script&gt;标签的src属性向后台接口发起请求（只支持GET请求），并且传递参数callback='response'，与此同时，前端必须定义函数response(responseData)，这是用来处理接口返回数据后一些操作。 当接口收到请求，返回数据格式为response(responseData)。这样，当前端接受到数据response(responseData)，就刚好执行了我们已经定义好的response(...) 当报错如下时： 原因是：后端接口没有返回callback(...) 维基百科 JSONP的原理和实现 CORS Cross Origin Resource Sharing，跨域资源共享，由一系列传输的HTTP头组成，这些HTTP头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应。 MDN文档 1、Access-Control-Allow-Origin：指示请求的资源能共享给哪些域 2、Access-Control-Allow-Credentials：指示当请求的凭证标记为true时，是否响应该请求 3、Access-Control-Allow-Headers：用在对预请求的响应中，哪些HTTP方法允许访问请求的资源 4、Access-Control-Expose-Headers：指示哪些HTTP头的名称能在响应中列出 5、Access-Control-Max-Age：指示预请求的结果能被缓存多久 6、Access-Control-Request-Headers：用于发起一个预请求，告知服务器正式请求会使用哪些HTTP头 7、Access-Control-Request-Method：用于发起一个预请求，告知服务器正式请求会使用哪一种HTTP请求方法 8、Origin：指示获取资源的请求是从什么域发起的 koa2中接口允许跨域响应，响应头部字段设置如下： 12345ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);ctx.set(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, OPTIONS, DELETE, PUT&#x27;);ctx.set(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;X-Requested-With, User-Agent, Referer, Content-Type, Cache-Control,accesstoken&#x27;); ctx.set(&#x27;Access-Control-Max-Age&#x27;, &#x27;86400&#x27;);ctx.set(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;); 注意事项： 若添加了自定义的Header字段，必须将这个字段名添加到服务端响应头部Access-Control-Allow-Headers中，不然会报错。 项目踩坑： 在接口响应中添加了以上允许跨域响应的头部字段，但是在开发中还报了跨域的错误（Response to preflight request doesn't pass access control check: Redirect is not allowed for a preflight request）,报错的大致意思是预检请求禁止重定向。经过排查，发现是服务端nginx做了HTTP到HTTPS的重定向设置，而我恰好是以http+ip地址的形式发起请求的，那么请求就被重定向到https了，然而，浏览器发起的预检请求是禁止重定向的，因此报错了。解决方案就是将请求地址改为https+域名的形式，这样预检请求就不会重定向了。","categories":[{"name":"其他","slug":"其他","permalink":"http://yonsunzhen.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"VS Code调试技巧","slug":"VS Code调试技巧","date":"2021-07-28T11:09:35.000Z","updated":"2023-05-18T14:27:34.595Z","comments":true,"path":"2021/07/28/VS Code调试技巧/","link":"","permalink":"http://yonsunzhen.github.io/2021/07/28/VS%20Code%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/","excerpt":"","text":"launch文件解读 必选属性： 1. type：启动配置的调试器的类型，以下为vs code提供的内置类型，还有一些类似于pwa-node，pwa-chrome是依靠插件提供的 node php go chrome 2. request：启动配置的请求类型，目前支持的是 launch 和 attach launch：启动 – 多用于对没启动的程序的处理 attach：附加 – 多用于对已经启动的程序的处理 3. name: 自定义名称，用于区分不同的调试配置（显示在“调试启动配置”下拉列表中） 常见可选属性 1. presentation ：呈现方式（在调试启动配置下的呈现方式） order：排序位置 hidden：是否隐藏 group：分组 2. preLaunchTask ：在调试会话开始之前启动一个任务 3. postDebugTask ：在调试会话的最后启动的一个任务 4. internalConsoleOptions ：此属性控制调试会话期间调试控制台面板的可见性 neverOpen：从不打开 openOnSessionStart：启动会话时打开 openOnFirstSessionStart：启动第一个会话时打开 部分可选属性 1. program ：启动调试器时要运行的文件 2. args ：传递给程序的参数 3. env ：环境变量 4. envFile： 环境变量文件的路径 5. cwd：用于查找依赖项和其他文件的当前工作目录 6. port ：连接到正在运行的进程时的端口 7. stopOnEntry ：当程序启动时立即中断 8. console ：使用console的方式 internalConsole integratedTerminal externalTerminal 一些变量 文档 $&#123;workspaceFolder&#125;：工作空间文件夹的根路径 $&#123;file&#125;：编辑器当前窗口打开的文件的路径 调试nodejs 注：调试nodejs时不能使用ES Module（import，export）来导入导出模块，需使用CommonJS （require，module.exports） launch.json文件配置： 123456789101112131415161718&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;debug nodejs&quot;, &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;&quot;, // 用于设置当前调试文件的根路径 默认为$&#123;workspaceFolder&#125; &quot;skipFiles&quot;: [ &quot;$&#123;workspaceFolder&#125;/node_modules/**/*.js&quot;, // 调试时不进入node_modules中的程序 &quot;&lt;node_internals&gt;/**&quot;, // 跳过内部node模块程序 ], &quot;program&quot;: &quot;debug.js&quot;, // 启动程序入口文件 必须使用绝对路径 // &quot;runtimeExecutable&quot;: &quot;npm&quot;, // 执行package.json中定义的script // &quot;runtimeArgs&quot;: [&quot;run-script&quot;, &quot;debug&quot;], // 执行package.json中定义的script &#125; ]&#125; 完整代码：点击访问 调试ts程序 背景：项目中在tsconfig.json文件中配置的路径别名，如果使用常规的tsc去编译程序是不能解析出路径别名的，因此引入了ts-node + tsconfig-paths/register来编译并执行程序 注：项目依赖中需要安装ts-node、typescript、tsconfig-paths launch.json文件配置： 123456789101112131415161718192021222324252627&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;ts-node&quot;, // 自定义名称 &quot;type&quot;: &quot;node&quot;, // 内置特定执行器 &quot;request&quot;: &quot;launch&quot;, &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;test&quot;, // 设置node环境变量 process.env.NODE_ENV 可以获取到这个值 &#125;, &quot;runtimeArgs&quot;: [ &quot;-r&quot;, &quot;ts-node/register&quot;, // 加载模块 ts-node/register &quot;-r&quot;, &quot;tsconfig-paths/register&quot; // 加载模块 tsconfig-paths/register ], &quot;skipFiles&quot;: [ &quot;$&#123;workspaceFolder&#125;/modules/assistant/node_modules/**/*.js&quot;, // 调试时跳过node_modules中的程序 必须使用绝对路径 &quot;&lt;node_internals&gt;/**&quot;, // 跳过内部node模块程序 ], &quot;cwd&quot;: &quot;$&#123;workspaceFolder&#125;/modules/assistant&quot;, // 对应runtimeArgs中找的模块的路径 &quot;protocol&quot;: &quot;inspector&quot;, &quot;program&quot;: &quot;./test/photography.spec.ts&quot;, // 拼接在cwd的路径后面或者使用绝对路径 &quot;internalConsoleOptions&quot;: &quot;openOnSessionStart&quot; &#125; ]&#125; 完整代码：点击访问 调试ng&amp;react 1、安装 Debugger for Chrome 插件 launch.json文件配置： 123456789101112131415&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;debug ng&quot;, // 自定义名称 &quot;url&quot;: &quot;http://localhost:4200&quot;, // 项目启动地址 &quot;skipFiles&quot;: [ &quot;$&#123;workspaceFolder&#125;/node_modules/**/*.js&quot;, // 调试时不进入node_modules中的程序 &quot;&lt;node_internals&gt;/**&quot;, // 跳过内部node模块程序 ] &#125; ]&#125; 完整代码：点击访问 调试python launch.json文件配置： 123456789101112&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;name&quot;: &quot;debug python&quot;, &quot;type&quot;: &quot;python&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/debug.py&quot;, // 调试的程序 &quot;console&quot;: &quot;integratedTerminal&quot; &#125; ]&#125; 完整代码：点击访问 参考资料 Debugging Debugging in VS Code Node.js debugging in VS Code Variables Reference","categories":[{"name":"其他","slug":"其他","permalink":"http://yonsunzhen.github.io/categories/%E5%85%B6%E4%BB%96/"}],"tags":[]},{"title":"依赖注入的那些事","slug":"依赖注入的那些事","date":"2021-01-20T08:33:48.000Z","updated":"2023-05-18T14:27:34.598Z","comments":true,"path":"2021/01/20/依赖注入的那些事/","link":"","permalink":"http://yonsunzhen.github.io/2021/01/20/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/","excerpt":"","text":"前言 1、控制反转：Inversion of Control，简称IoC 2、依赖注入：Dependency Injection，简称DI，依赖注入实际上是控制反转概念的一种实现模式。一种消除类之间依赖关系的设计模式。 假设我们有一个类Human，要实例一个Human，我们需要实例一个类Clothes，而实例化衣服Clothes，我们又需要实例化Cloth，实例化纽扣等等。 当需求达到一定复杂的程度时，我们不能为了一个人穿衣服去从布从纽扣开始从头实现，最好能把所有的需求放到一个工厂或者仓库，我们需要什么直接从工厂的仓库里面直接拿（与直接封装成一个Clothes类，我们需要时再去new有什么区别? – 假如去new实例的话，那类与类之间还是存在着依赖关系）。 这个时候就需要依赖注入了，我们实现一个IoC容器（仓库），然后需要衣服就从仓库里面直接拿实例化出来的衣服给人作为属性穿上去就行了。 将所有的类与类之间的依赖关系交给IoC容器去管理，之后真正使用的是IoC容器中已存在依赖关系的类的实例（并非再去new新的实例，因此并不会影响类源代码逻辑，个人猜想：若后面需要扩展需求可以根据源类再创建别的容器） IoC是一种很好的解耦合思想，在开发中，IoC意味着你设计好的对象交给容器控制，而不是使用传统的方式，在对象内部直接控制。在软件开发中有很好的作用。 基于ts中装饰器的使用 类装饰器 类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数 可以用来监视，修改或替换类定义 修改类的构造器： 123456789101112131415161718192021222324function classDecorator&lt;T extends &#123;new(...args:any[]):&#123;&#125;&#125;&gt;(constructor:T) &#123; console.log(&#x27;装饰器已执行&#x27;); return class extends constructor &#123; newProperty = &quot;new property&quot;; hello = &quot;override&quot;; &#125;&#125;@classDecoratorclass Greeter &#123; property = &quot;property&quot;; hello: string; constructor(m: string) &#123; this.hello = m; console.log(this.hello); &#125;&#125;console.log(new Greeter(&quot;world&quot;));// 装饰器已执行// world// Greeter &#123;// property: &#x27;property&#x27;,// hello: &#x27;override&#x27;,// newProperty: &#x27;new property&#x27;// &#125; 程序运行顺序： 1、为类Greeter添加装饰内容（加在原来类的构造函数后面，因此能起到重写构造函数属性的效果）； 2、实例化类； 修改类的某个方法： 12345678910111213141516171819202122232425function cheating(target: any) &#123; target.prototype.hit = function(rival: Somebody) &#123; const hitDamage: number = 100; console.log(`$&#123;this.name&#125;对$&#123;rival.name&#125;造成一次伤害: $&#123;hitDamage&#125;`); &#125;&#125;class Somebody &#123; speed: number = 10; name: string; constructor(name: string) &#123; this.name = name; &#125; hit(rival: Somebody) &#123; const hitDamage: number = 10; console.log(`$&#123;this.name&#125;对$&#123;rival.name&#125;造成一次伤害：$&#123;hitDamage&#125;`); &#125;&#125;@cheatingclass SBody extends Somebody&#123;&#125;const s0 = new Somebody(&#x27;小红0&#x27;);const s1 = new SBody(&#x27;小红1&#x27;);const rival = new Somebody(&#x27;小明&#x27;);s0.hit(rival); // 小红0对小明造成一次伤害：10s1.hit(rival); // 小红1对小明造成一次伤害: 100 属性装饰器 当要装饰的属性为实例属性时（没有static修饰），装饰的是该类原型上的属性 123456789101112131415161718192021222324252627282930function logProperty(params: any) &#123; // target---&gt;类的原型对象；attr---&gt;装饰的属性名 return function (target: any, attr: any) &#123; target[attr] = params; &#125;&#125; class HttpClient1 &#123; @logProperty(&#x27;http://www.baidu1.com&#x27;) url: any | undefined; constructor() &#123; &#125; getUrl() &#123; console.log(this.url); &#125;&#125;class HttpClient2 &#123; @logProperty(&#x27;http://www.baidu22.com&#x27;) url: any | undefined = &#x27;http://www.baidu2.com&#x27;; constructor() &#123; &#125; getUrl() &#123; console.log(this.url); &#125;&#125;let http1 = new HttpClient1();http1.getUrl(); // http://www.baidu1.com HttpClient1类中url没有初始化，因此获取的是原型链上的值let http2 = new HttpClient2();http2.getUrl(); // http://www.baidu2.com 获取的是HttpClient2中url初始化的值（先确定自身对象中是否有这个值，没有的话再去原型链上找，再没有就返回undefined） 当要装饰的属性为静态属性时（static修饰），装饰的是该类上的静态属性 123456789101112131415161718192021222324252627function logProperty(params: any) &#123; // target---&gt;类；attr---&gt;装饰的属性名 return function (target: any, attr: any) &#123; target[attr] = params; &#125;&#125; class HttpClient1 &#123; @logProperty(&#x27;http://www.baidu1.com&#x27;) static url: any | undefined; constructor() &#123; &#125; getUrl() &#123; console.log(HttpClient1.url); &#125;&#125;class HttpClient2 &#123; @logProperty(&#x27;http://www.baidu22.com&#x27;) static url: any | undefined = &#x27;http://www.baidu2.com&#x27;; constructor() &#123; &#125; getUrl() &#123; console.log(HttpClient2.url); &#125;&#125;console.log(HttpClient1.url); // http://www.baidu1.comconsole.log(HttpClient2.url); // http://www.baidu22.com 程序运行顺序： 1、为属性执行装饰器函数（给原型上对应属性赋值 || 给类静态属性赋值 || 其他逻辑操作）; 2、实例化类； 参数装饰器 12345678910111213141516171819202122232425262728// 参数装饰器 接受3个参数// target: Object —— 被装饰的参数所在的方法的类// methodName: string | symbol —— 方法名// paramsIndex: number —— 方法中参数的索引值// 在构造器中的参数使用function logParams(params: any) &#123; return function (target: any, methodName: any, paramsIndex: any) &#123; console.log(1, params); console.log(2, target); console.log(3, methodName); console.log(4, paramsIndex); &#125;&#125;class HttpClient &#123; public url: any | undefined; constructor() &#123; &#125; getData(@logParams(&#x27;uuid&#x27;) uuid: any) &#123; console.log(uuid); &#125;&#125;let http = new HttpClient();http.getData(123456);// 1 uuid// 2 HttpClient &#123;&#125;// 3 getData// 4 0// 123456 reflect-metadata 当想要给类中的某个属性或类构造函数中某个参数设置元数据时，一般采用reflect-metadata这种方式（暂未找到其他方式，原生js如何给一个对象属性设置元数据???，通过反射来获取类属性上面的批注） 1234567import &#x27;reflect-metadata&#x27;;class Post &#123; @Reflect.metadata(&#x27;role&#x27;, &#x27;admin&#x27;) haha: &#123;haha?: string; test?: number&#125;&#125;const metadata = Reflect.getMetadata(&#x27;role&#x27;, Post.prototype, &#x27;haha&#x27;);console.log(metadata); // admin 1、可以用于给类中一些属性设置一些元数据。元数据指的是表述东西时用的数据 2、Reflect.metadata：可以用于给某个类中的某个属性值添加一个元数据（键值对） 3、Reflect.getMetadata：获取某个类中某个属性值的某个元数据（并不会干扰到原来的属性值） 123456789101112131415161718192021222324import &quot;reflect-metadata&quot;;// 用来记录某个属性的元数据const formatMetadataKey = Symbol(&quot;format&quot;);function format(formatString: string) &#123; // Reflect.metadata返回一个函数 (target: Object, propertyKey: string | symbol): void return Reflect.metadata(formatMetadataKey, formatString);&#125;function getFormat(target: any, propertyKey: string) &#123; // 获取类中propertyKey的某个元数据(批注) return Reflect.getMetadata(formatMetadataKey, target, propertyKey);&#125;class Greeter &#123; @format(&quot;Hello, %s&quot;) greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; let formatString = getFormat(this, &quot;greeting&quot;); return formatString.replace(&quot;%s&quot;, this.greeting); &#125;&#125;const test = new Greeter(&#x27;syz&#x27;).greet();console.log(test); // Hello, syz reflect-metadata参考1 reflect-metadata参考2 程序调试技巧 1、使用VS Code配合插件Code Runner（鼠标框选程序右键Run Code即可），因为程序使用的是typescript，使用Code Runner运行需要在全局安装ts-node（npm install ts-node -g）和 typescript（npm install typescript -g） 在文件同级目录下配置一下tsconfig.json文件即可 12345678910111213141516171819&#123; &quot;compileOnSave&quot;: false, &quot;buildOnSave&quot;: false, &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;target&quot;: &quot;ES6&quot;, &quot;emitDecoratorMetadata&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;noImplicitAny&quot;: true, &quot;removeComments&quot;: false, &quot;sourceMap&quot;: false, &quot;inlineSourceMap&quot;: true, &quot;noEmitHelpers&quot;: false, &quot;declaration&quot;: true, &#125;&#125; 2、备注：tsc xxx.js可将ts文件编译为js文件，可以查看编译后的js代码，可能更容易理解！ 简易DI实现 涉及到类装饰器 &amp; 属性装饰器的使用 思路流程 1、实现一个IoC容器 Injector ，并实例化一个根容器rootInjector（用于存放各个依赖的工厂容器） 2、实现一个依赖注入方法Injectable(...)（用于将各个依赖类注入根容器） 3、实现基于注解的属性注入方法Inject(...)（将类需要用到的依赖从根容器取出来并注入到类中，若根容器不存在则创建此依赖） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import &#x27;reflect-metadata&#x27;;// 工厂里面的各种操作export class Injector &#123; private readonly providerMap: Map&lt;any, any&gt; = new Map(); private readonly instanceMap: Map&lt;any, any&gt; = new Map(); public setProvider(key: any, value: any): void &#123; if (!this.providerMap.has(key)) &#123; this.providerMap.set(key, value); &#125; &#125; public getProvider(key: any): any &#123; return this.providerMap.get(key); &#125; public setInstance(key: any, value: any): void &#123; if (!this.instanceMap.has(key)) this.instanceMap.set(key, value); &#125; public getInstance(key: any): any &#123; if (this.instanceMap.has(key)) return this.instanceMap.get(key); return null; &#125; public setValue(key: any, value: any): void &#123; if (!this.instanceMap.has(key)) this.instanceMap.set(key, value); &#125;&#125;// 表示根注入器(用于存放各个依赖的根容器)export const rootInjector = new Injector();// 将类注入到工厂中 类装饰器返回一个值，它会使用提供的构造函数来替换原来类的声明export function Injectable(): (_constructor: any) =&gt; any &#123; return function (_constructor: any): any &#123; rootInjector.setProvider(_constructor, _constructor); return _constructor; &#125;;&#125;// 将依赖注入到生产者export function Inject(): (_constructor: any, propertyName: string) =&gt; any &#123; return function (_constructor: any, propertyName: string): any &#123; // 获取属性定义时的类型 const propertyType: any = Reflect.getMetadata(&#x27;design:type&#x27;, _constructor, propertyName); const injector: Injector = rootInjector; let providerInsntance = injector.getInstance(propertyType); if (!providerInsntance) &#123; const providerClass = injector.getProvider(propertyType); providerInsntance = new providerClass(); injector.setInstance(propertyType, providerInsntance); &#125; _constructor[propertyName] = providerInsntance; &#125;;&#125;@Injectable()class Cloth &#123; name: string = &#x27;麻布&#x27;;&#125;@Injectable()class Clothes &#123; // 为类Clothes注入类Cloth 之后类Clothes就拥有了使用类Cloth的能力 @Inject() cloth: Cloth; clotheName: string; constructor() &#123; this.cloth = this.cloth; this.clotheName = this.clotheName; &#125; updateName(name: string) &#123; this.clotheName = name; &#125;&#125;class Human1 &#123; @Inject() clothes: Clothes; name: string; constructor(name: string) &#123; this.clothes = this.clothes; this.name = name; &#125; update(name: string) &#123; this.clothes.updateName(name); &#125;&#125;// 单例：用于数据状态的维护(一个变 所有变)const pepe1 = new Human1(&#x27;syz&#x27;);console.log(pepe1);// Human1 &#123;// clothes: Clothes &#123; cloth: Cloth &#123; name: &#x27;麻布&#x27; &#125;, clotheName: undefined &#125;// &#125;pepe1.update(&#x27;耐克&#x27;);console.log(pepe1);// Human1 &#123;// clothes: Clothes &#123; cloth: Cloth &#123; name: &#x27;麻布&#x27; &#125;, clotheName: &#x27;耐克&#x27; &#125;// &#125; 简易DI参考 仿Angular中的DI service依赖注入，使用单例模式，以后单个或多个组件需要使用这个服务时，都是共享同一个实例（因此可用于状态共享），极大的减少了内存资源的损耗。 在某个注入器的范围内，服务是单例的。也就是说，在指定的注入器中最多只有某个服务的最多一个实例。 应用只有一个根注入器。在root或AppModule级提供UserService意味着它注册到了根注入器上。在整个应用中只有一个UserService实例，每个要求注入UserService的类都会得到这一个服务实例，除非你在子注入器中配置了另一个提供者 1、如何将依赖从容器中取出来呢 – 调用inject()方法会返回类的实例（Reflect.construct(...)用于实例化，接着调用了类的构造函数，将对应的依赖实例作为构造函数参数传进去） 2、写在类中constructor()中的参数都是要注入依赖的。普通类型，例如string，number不能写进去，否则报错 相关技术： 1、类装饰器，配合reflect-metadata 2、参数装饰器，配合reflect-metadata 代码实现 1、实现Injectable()类装饰器，用于标记类是否可被注入容器中 123456789101112131415import &#123; Type &#125; from &#x27;./type&#x27;;import &#x27;reflect-metadata&#x27;;const INJECTABLE_METADATA_KEY = Symbol(&#x27;INJECTABLE_KEY&#x27;);// 必须被这个装饰器修饰的Class才说明是可以被注入的 (表示Class自己承认是可被注入的)export function Injectable() &#123; return function(target: any) &#123; Reflect.defineMetadata(INJECTABLE_METADATA_KEY, true, target); return target; &#125;&#125;// 检查Class是否可被注入export function isInjectable&lt;T&gt;(target: Type&lt;T&gt;) &#123; return Reflect.getMetadata(INJECTABLE_METADATA_KEY, target) === true;&#125; 2、实现Inject()参数装饰器，用于将value值注入类中 1234567891011121314151617import &#123; Token &#125; from &#x27;./provider&#x27;;import &#x27;reflect-metadata&#x27;;const INJECT_METADATA_KEY = Symbol(&#x27;INJECT_KEY&#x27;);// 参数装饰器 接受3个参数// target: Object —— 被装饰的参数所在的方法的类// methodName: string | symbol —— 方法名// parameterIndex: number —— 方法中参数的索引值// 在构造器中的参数使用export function Inject(token: Token&lt;any&gt;) &#123; return function(target: any, _: string | symbol, index: number) &#123; Reflect.defineMetadata(INJECT_METADATA_KEY, token,target,`index-$&#123;index&#125;`); return target; &#125;;&#125;export function getInjectionToken(target: any, index: number) &#123; return Reflect.getMetadata(INJECT_METADATA_KEY, target, `index-$&#123;index&#125;`) as Token&lt;any&gt; | undefined;&#125; 3、实现addProvider(...)方法，用于将所有需要注入到容器的所有类/值添加到 providers变量中，后续inject(...)将从providers取值 4、实现inject(...)方法，将类注入容器并返回实例（使用Reflect.construct方法） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687export class Container &#123; providers = new Map&lt;Token&lt;any&gt;, Provider&lt;any&gt;&gt;(); instances = new Map&lt;Token&lt;any&gt;, any&gt;(); addProvider&lt;T&gt;(provider: Provider&lt;T&gt;) &#123; this.assertInjectableIfClassProvider(provider); // 重复注入同个类的话 貌似是以后面的为准??? this.providers.set(provider.provide, provider); &#125; inject&lt;T&gt;(type: Token&lt;T&gt;): T &#123; let provider = this.providers.get(type); let instance = this.instances.get(type); if(provider === undefined &amp;&amp; !(type instanceof InjectionToken)) &#123; provider = &#123; provide: type, useClass: type &#125;; this.assertInjectableIfClassProvider(provider); &#125; // 容器中是否已存在实例 存在的话直接返回原有的实例 共享变量 if(instance) &#123; return instance; &#125; return this.injectWithProvider(type, provider); &#125; private assertInjectableIfClassProvider&lt;T&gt;(provider: Provider&lt;T&gt;) &#123; if(isClassProvider(provider) &amp;&amp; !isInjectable(provider.useClass)) &#123; throw new Error( `Cannot provide $&#123;this.getTokenName(provider.provide)&#125; using class $&#123;this.getTokenName( provider.useClass )&#125;, $&#123;this.getTokenName(provider.useClass)&#125; isn&#x27;t injectable` ); &#125; &#125; private getTokenName&lt;T&gt;(token: Token&lt;T&gt;) &#123; return token instanceof InjectionToken ? token.injectionIdentifier : token.name &#125; private injectWithProvider&lt;T&gt;(type: Token&lt;T&gt;, provider?: Provider&lt;T&gt;): T &#123; let instance; if (provider === undefined) &#123; throw new Error(`No provider for type $&#123;this.getTokenName(type)&#125;`); &#125; if (isClassProvider(provider)) &#123; instance = this.injectClass(provider as ClassProvider&lt;T&gt;); &#125; else if (isValueProvider(provider)) &#123; instance = this.injectValue(provider as ValueProvider&lt;T&gt;); &#125; else &#123; instance = this.injectFactory(provider as FactoryProvider&lt;T&gt;); &#125; this.addInstances(type, instance); return instance; &#125; // 关键 在实例化服务类时 需要构造该服务类依赖的独享(即在构造函数中注入的依赖) private injectClass&lt;T&gt;(classProvider: ClassProvider&lt;T&gt;): T &#123; const target = classProvider.useClass; const params = this.getInjectedParams(target); // 这里的作用 类似于 new target(...params) return Reflect.construct(target, params); &#125; private injectValue&lt;T&gt;(valueProvider: ValueProvider&lt;T&gt;): T &#123; return valueProvider.useValue; &#125; private injectFactory&lt;T&gt;(factoryProvider: FactoryProvider&lt;T&gt;): T &#123; return factoryProvider.useFactory(); &#125; // 用于获取类构造函数中声明的依赖对象 重点&amp;难点 private getInjectedParams&lt;T&gt;(target: Type&lt;T&gt;) &#123; // 获取参数的类型 &quot;design:paramtypes&quot; 用于修饰目标对象方法的参数类型 const argTypes = Reflect.getMetadata(REFLECT_PARAMS, target) as (InjectableParam | undefined)[]; if(argTypes === undefined) &#123; return []; &#125; return argTypes.map((argTypes, index) =&gt; &#123; if(argTypes === undefined) &#123; throw new Error ( `Injection error. Recursive dependency detected in constructor for type $&#123;target.name&#125; with parameter at index $&#123;index&#125;` ); &#125; const overrideToken = getInjectionToken(target, index); const actualToken = overrideToken === undefined ? argTypes : overrideToken; let provider = this.providers.get(actualToken); // 递归调用 一层接一层 return this.injectWithProvider(actualToken, provider); &#125;); &#125; // 已注入容器的实例添加到变量instances private addInstances&lt;T&gt;(type: Token&lt;T&gt;, instance: any) &#123; this.instances.set(type, instance); &#125;&#125; 4、调用demo 123456789101112131415161718192021222324252627282930313233343536import &#123; Container &#125; from &#x27;./container&#x27;;import &#123; Injectable &#125; from &#x27;./Injectable&#x27;;import &#123; Inject &#125; from &#x27;./Inject&#x27;;import &#123; InjectionToken &#125; from &#x27;./provider&#x27;;const API_URL = new InjectionToken(&#x27;apiUrl&#x27;);@Injectable()class HttpClient&#123; get() &#123; console.log(&#x27;get&#x27;); &#125;&#125;@Injectable()class HttpService &#123; constructor( // 使用这种方式是如何将HttpClient注入的 使用Reflect.getMetadata(&#x27;design:paramtypes&#x27;, target)获取target类的参数类型信息 private httpClient: HttpClient, @Inject(API_URL) private apiUrl: string, ) &#123; &#125; test() &#123; console.log(this.apiUrl); this.httpClient.get(); &#125;&#125;const container = new Container();// addProvider 这一步就相当于angular中在module中的providers添加Servicecontainer.addProvider(&#123; provide: API_URL, useValue: &#x27;https://www.666.com/&#x27;&#125;);container.addProvider(&#123;provide: HttpService, useClass: HttpService &#125;);container.addProvider(&#123;provide: HttpClient, useClass: HttpClient &#125;);const httpService = container.inject(HttpService);httpService.test();// https://www.666.com/// get 关键点 1、Reflect.getMetadata('design:paramtypes', value)：获取类构造函数参数的类型 2、Reflect.construct(data, params)：实例化类 3、类中依赖如果存在多层采用递归注入方式 完整代码 查看 疑问 1、一种消除类之间依赖关系的设计模式，具体是如何体现的？貌似还是存在依赖，只是封装起来了而已？ 解答：将所有的类与类之间的依赖关系交给IoC容器去管理，之后真正使用的是IoC容器中已存在依赖关系的类的实例（并非再去创建新的实例，因此并不会影响类源代码逻辑，个人猜想：若后面需要扩展需求可以根据源类再创建别的容器）； 2、angular中同个Service在多个地方注入，获取依赖时如何确定要获取哪一个值？ 解答：如果是在同一个注入容器重复注入，按照注入的先后顺序，后面注入的会重写前面注入的； 3、在construct中private httpClient: HttpClient是如何将HttpClient注入依赖的？ 解答：使用Reflect.getMetadata('design:paramtypes', target)获取target类的参数类型信息；","categories":[{"name":"Angular","slug":"Angular","permalink":"http://yonsunzhen.github.io/categories/Angular/"}],"tags":[]},{"title":"JavaScript中异步与同步，回调函数，promise，async与await之满汉全席","slug":"JavaScript中异步与同步，回调函数，promise，async与await之满汉全席","date":"2020-12-25T07:36:36.000Z","updated":"2023-05-18T14:27:34.594Z","comments":true,"path":"2020/12/25/JavaScript中异步与同步，回调函数，promise，async与await之满汉全席/","link":"","permalink":"http://yonsunzhen.github.io/2020/12/25/JavaScript%E4%B8%AD%E5%BC%82%E6%AD%A5%E4%B8%8E%E5%90%8C%E6%AD%A5%EF%BC%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8Cpromise%EF%BC%8Casync%E4%B8%8Eawait%E4%B9%8B%E6%BB%A1%E6%B1%89%E5%85%A8%E5%B8%AD/","excerpt":"","text":"一、异步与同步 理解异步与同步 1、在生活中，按照字面量来理解，异步指的是，比如我先吃完苹果再看电视，这是我们生活中理解的异步。同步就是我边吃苹果边看电视。 2、然而，对我们的电脑程序来说，同步与异步的概念恰恰跟我们在生活中的理解完全相反。同步指的是我先吃完苹果，然后再看电视（执行完一个事件再去执行另一个事件，若上一个事件没执行完，下一个事件就无法执行）；异步指的是我边吃苹果边看电视（多个事件可以同时执行，不会发生阻塞）。理解js中的异步和同步，如果对这两个概念混淆了，你只要想到跟我们生活中异步与同步的理解相反就行了。 谈谈JavaScript的单线程机制 单线程是JavaScript中一个比较重要的特性。这就表示在同一个时间只能做一件事情。 那为什么JavaScript不弄成多线程的呢？还能更加充分利用CPU呢。 这要从JavaScript的使用场景说起，JavaScript作为浏览器语言，主要用途是通过操作DOM，与用户进行交互。 我们设想一下，如果一个线程去更新某个DOM元素，而另一个线程去删除这个DOM元素，那么浏览器该执行哪个操作呢？这就出现冲突了。 因此，为了避免复杂的多线陈机制，JavaScript从设计之初就选择了单线程标准。 Event Loop 事件循环 单线程那就表示事件只能一个一个轮着执行，前面没执行完后面就无法执行（只能干等着，这样也太低效了）。比如，我用ajax向服务端请求一个数据（假设数据量很大，花费时间很久），这时候就会卡在那里，因为后面的只能等前一个事件把数据成功请求回来再执行接下的代码，这样对用户的体验就太不友好了。这时候 任务队列 就出场了。JS中将所有任务分为同步任务和 异步任务。 目前个人的理解是，只有所有的同步任务执行完才会去执行异步任务。常见的异步任务有setTimeout函数，http请求，数据库查询等。 （1）所有任务都在主线程上执行，形成一个执行栈（execution context stack）。 （2）主线程之外，还存在一个&quot;任务队列&quot;（task queue）。系统把异步任务放到&quot;任务队 列&quot;之中，然后继续执行后续的任务。 （3）一旦&quot;执行栈&quot;(事件循环队列)中的所有任务执行完毕，系统就会读取&quot;任务队列&quot;。如果这个时候，异步任务已经结束了等待状态，就会从&quot;任务队列&quot;进入执行栈，恢复执行。 （4）主线程不断重复上面的第三步。 详情查看此文章 12345678910111213console.log(&#x27;这里是调试1&#x27;);setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;);&#125;,0)console.log(&#x27;这里是调试3&#x27;);console.log(&#x27;这里是调试4&#x27;);console.log(&#x27;这里是调试5&#x27;);// 输出这里是调试1这里是调试3这里是调试4这里是调试5这里是调试2 // setTimeout中的最后面才输出来 异步任务之微任务&amp;宏任务 异步任务分为宏任务（macrotasks）和微任务（microtasks）。常见的宏任务有（setTimeout，setInterval，setImmediate），常见的微任务有（Promise.then）。在一个事件循环中，当执行完所有的同步任务后，会在任务队列中取出异步任务，这时候会优先执行微任务，接着再执行宏任务。换句话说，微任务就是为了插队而存在的。看一下下面这个例子： 12345678setTimeout(() =&gt; console.log(1));new Promise((resolve) =&gt; &#123; resolve(); console.log(2);&#125;).then(() =&gt; &#123; console.log(3);&#125;)console.log(4); 输入结果为：2 - 4 - 3 - 1 setTimeout(…)相关 1、在setTimeout(...)中可以用async(...)，await(...)，但是只能当前setTimeout(...)执行栈中生效； 2、同一层级的多个setTimeout(...)相互独立，就算setTimeout(...)中有await(...)也不会影响到其他setTimeout(...)的执行； 阮一峰 JavaScript运行机制详解 朴灵 标注 mdn 选择异步还是同步？ 1、在JS中默认的方式是同步的，个别是异步的（http请求，setTimeout）。假设现在有一个场景，我们需要从后端接口获取数据（异步任务），然后对该数据进行处理，这时候我们就需要将获取数据这一异步任务阻塞，也就是将其转化为同步任务。 2、常见的处理异步（将异步变为同步）的方式按照出现时间排序有：回调函数，Promise，async与await。 二、闭包与回调函数 1、无论通过何种手段将内部函数传递到这个函数定义时的词法作用域(定义时的词法作用域指的是函数定义时的那个位置)以外执行，内部函数都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。 2、无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。 3、闭包使得函数可以继续访问定义时的词法作用域。 4、只要使用了回调函数，实际上就是在使用闭包。 —《你不知道的JavaScript》 1、一般来说，block（块级）作用域被执行完后，里面的数据就被回收了。 2、作用： 将某个块级作用域里面的变量可以被外部使用。 3、词法作用域：静态作用域，查找作用域的顺序是按照函数定义时的位置来决定的。 4、全局作用域是在V8启动过程中就创建了，且一直保存在内存中不会被销毁的，直到V8退出。而函数作用域是在执行该函数时创建的，当函数执行结束之后，函数作用域就随之被销毁了。 我们来看一个闭包的案例： 1234567891011function foo() &#123; let a = 2; function bar() &#123; console.log(a); a++; &#125; return bar;&#125;let baz = foo();baz(); // 2baz(); // 3 函数foo(...)中返回了一个名为bar的函数，接着 let baz = foo();就将bar(...)这个函数赋值给了baz，所以在一定程度上baz相当于bar(...)，接着我们就执行baz（在bar定义时的词法作用域以外执行了）（词法作用域： 函数在哪里定义，他的词法作用域就在哪里）；这也就印证了我们前面说的，将一个内部函数传递到这个函数所在的词法作用域以外执行，所以就产生了闭包，因为我们在外面获取到了foo函数内部的变量a，同时这也是闭包产生的效果。 3、总结： 什么时候产生闭包： 将一个函数传递到这个函数所在的词法作用域以外执行； 闭包的作用： 引用某个块级作用域里面变量（持续引用） 4、只要使用了回调函数，实际上就是在使用闭包。下面我们来看一个案例。 123456function wait(message) &#123; setTimeout(function timer() &#123; console.log(message); &#125;, 1000);&#125;wait(&#x27;Hello, World&#x27;); 将一个内部函数（名为timer）传递给setTimeout(...)。timer具有涵盖wait(...)作用域的闭包，因此还保有对变量message的引用。wait(...)执行1000毫秒后，它的内部作用域并不会消失，timer函数依然保有wait(...)作用域的闭包。因为它可以引用到message这个变量。 5、下面我们来看一个稍微复杂点的案例（利用回调函数进行同步传值）： 1234567891011121314// 模拟获取ajax请求的数据(异步)function getAjaxData(cb) &#123; // 用setTimeout实现异步请求 setTimeout(function() &#123; // 假设data是我们请求得到的数据 我们需要将数据发送给别人 const data = &quot;请求得到的数据&quot;; cb(data); &#125;, 1000)&#125;// 获取ajax请求的响应数据并对数据进行处理getAjaxData(function handleData(tempData) &#123; tempData = tempData + &#x27;666&#x27;; console.log(tempData); // 请求得到的数据666&#125;); 将handleData(...)作为参数传进getAjaxData(...)中，因此cb(data)中的data就作为参数传进了handleData(...)中，这样也就达到了传值的作用了。 6、回调函数存在的问题：信任问题。以上面的例子进行改进。 1234567891011121314function getAjaxData (cb) &#123; // 用setTimeout实现异步请求 setTimeout(function () &#123; // 假设data是我们请求得到的数据 我们需要将数据发送给别人 const data = &quot;请求得到的数据&quot;; cb(data); cb(data); &#125;, 1000)&#125;// 获取ajax请求的响应数据并对数据进行处理getAjaxData(function handleData (tempData) &#123; tempData = tempData + &#x27;666&#x27;; console.log(tempData); // 请求得到的数据666&#125;); 假设getAjaxData(...)这个方法是由第三方库引进来的，我们并不清楚里面的代码逻辑细节，这样的话handleData(...)的执行就存在不确定性，比如上面我增加了一个cb(data)，这handleData(...)就会执行两次，当然这不是我们想要的效果，因此回调的处理就不可控了。 回调最大的问题是控制反转，它会导致信任链的完全断裂。 因为回调函数内部的调用情况是不确定的，可能不调用，也可能被调用了多次。 —《你不知道的JavaScript》 Promise的出现正是为了解决这个问题。 7、备注： 关于js中内存回收的问题 三、Promise Promise一旦决议（resolve），一直保持其决议结果不变 解决回调调用过早的问题 解决回调调用过晚的问题 解决回调未调用的问题 解决调用次数过少或过多 Promise API概述 1、new Promise(…)构造器 2、Promise.resolve(…)和Promise.reject(…) 3、then(…)和catch(…) 4、Promise.all([…])和Promise.race([…]) Promise源码解读 1、new Promise 时，需要传递一个executor执行器，执行器立刻执行； 2、executor 接受两个参数，分别是resolve和reject； 3、promise 只能从 pending 到 rejected，或者从 pending 到 fulfilled； 4、promise 的状态一旦确认，就不会再改变； 5、promise都有then方法，then接受两个参数，分别是promise成功的回调 onFulfilled，和promise失败的回调onRejected； 6、如果调用then时，promise已经成功，则执行onFulfilled，并将promise的值作为参数传递进去。如果promise已经失败，那么执行onRejected，并将promise失败的原因作为参数传递进去。如果promise的状态是pending，需要将onFulfilled和onRejected函数存放起来，等待状态确定后，再依次将对应的函数执行； 7、then的参数onFulfilled和onRejected可以缺省； 8、promise可以then多次，promise的then方法返回一个promise； 9、如果then返回的是一个结果，那么就会把这个结果作为参数，传递给下一个then的成功的回调（onFulfilled）； 10、如果then中抛出异常，那么就会把这个异常作为参数，传递给下一个then的失败的回调（onRejected）； 11、如果then返回的是一个promise，那么就会等这个promise执行完，promise如果成功，就走下一个then的成功，如果失败，就走下一个then的失败； 流程 1、当promise中有异步任务：如果promise中有异步任务的话，那他的status为pedding，之后所有的then都会放到待办任务数组里面。 2、链式调用的实现：then方法返回一个promise。 3、当then中有异步任务：两种情况： 仅仅是一个异步任务：按照正常情况来，会再最后面输出。 异步任务在一个promise中，并且该promise有return：后面的所有then会放进待办任务数组中，这种情况会等到return的promise resolve(...)之后，将状态改变之后才会再执行后面的(遍历待办任务数组)，也就是相当于将then(...)中的异步任务阻塞了。 源码实现&amp;解析 1、实现promise(...)方法，该方法有一个回调函数exectue参数 ； 当我们new promise((resolve, reject) =&gt; &#123;&#125;);时，将会执行该回调函数 ； 并且resolve对应到promise(...)中的res(...) ； reject对应到promise(…)中的rej(...)； 当我们执行到resolve(...)时，才会执行res(...)； 1234567891011121314151617181920function promise(exectue) &#123; const res = (value) =&gt; &#123; &#125; const rej = (reason) =&gt; &#123; &#125; exectue(res, rej);&#125;// resolve对应的是promise(...)中的res(...)// reject对应的是promise(...)中的rej(...)// 因此只有执行了resolve(...)或reject(...) 才改变status的值const test = new promise((resolve, reject) =&gt; &#123; console.log(&#x27;这里是调试1&#x27;); setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;); resolve(); &#125;, 3000)&#125;)// 这里是调试1// 这里是调试2// 执行了res 2、promise(...)方法中维护几个变量，用于存储执行节点的状态&amp;数据： fulfilled：标志任务是否已完成状态； pedding：标志任务是否正在进行中状态（未完成状态）； status：标志当前执行节点的状态，节点的初始状态为pedding； value：存储promise状态成功时的值； reason：存储promise状态失败时的值； onFulfilledCallbacks ：数组，存储成功的回调任务； onRejectedCallbacks：数组，存储失败的回调任务； 12345678910111213141516171819202122232425262728function promise(exectue) &#123; this.fulfilled = &#x27;fulfilled&#x27;; this.pedding = &#x27;pedding&#x27;; this.rejected = &#x27;rejected&#x27;; this.status = this.pedding; this.value; this.reason; this.onFulfilledCallbacks = []; this.onRejectedCallbacks = []; const res = (value) =&gt; &#123; if(this.status === this.pedding) &#123; // 执行了resolve就要改变status为fulfilled this.status = this.fulfilled; this.value = value; // 遍历执行放在待办任务数组中的事件 this.onFulfilledCallbacks.forEach(fn =&gt; fn()); &#125; &#125; const rej = (reason) =&gt; &#123; if(this.status === this.pedding) &#123; // 执行了reject就要改变status为rejected this.status = this.rejected; this.reason = reason; this.onRejectedCallbacks.forEach(fn =&gt; fn()); &#125; &#125; exectue(res, rej);&#125; 3、实现then(...)，为符合链式调用，then(...)方法必须返回一个promise(...)： 123456789101112131415161718192021222324252627promise.prototype.then = function (onFulfilled, onRejected) &#123; // this指向promise(...)对象 const that = this; const promise2 = new promise((resolve, reject) =&gt; &#123; if(that.status === that.fulfilled) &#123; onFulfilled(); resolve(); &#125; if(that.status === that.pedding) &#123; &#125; if(that.status === that.rejected) &#123; &#125; &#125;) return promise2;&#125;// 调用const test = new promise((resolve, reject) =&gt; &#123; console.log(&#x27;这里是调试1&#x27;); resolve();&#125;)test.then(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;);&#125;).then(() =&gt; &#123; console.log(&#x27;这里是调试3&#x27;);&#125;)// 这里是调试1// 这里是调试2// 这里是调试3 4、到这里，我们已实现了基本的链式调用的功能了，那如果在promise(...)中是一个异步事件时，并且我们需要阻塞这个异步任务（将异步转化为同步），预计的效果是只有执行了resolve(...)才能执行then(...)中的代码，可以怎么实现呢？ 当promise(...)中是需要阻塞的异步任务时，那么当执行到then(...)时，此时的status为pedding，需要将链式调用的执行节点根据Fulfilled或Rejected两种情况分别添加到onFulfilledCallbacks或onRejectedCallbacks这两个变量中，等到异步任务执行完，resolve(...)之后才轮到链式调用节点的执行，改进代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243promise.prototype.then = function (onFulfilled, onRejected) &#123; // this指向promise(...)对象 const that = this; const promise2 = new promise((resolve, reject) =&gt; &#123; if(that.status === that.fulfilled) &#123; onFulfilled(); resolve(); &#125; if(that.status === that.pedding) &#123; console.log(&#x27;这里是调试4&#x27;); this.onFulfilledCallbacks.push(() =&gt; &#123; onFulfilled(); resolve(); &#125;) &#125; if(that.status === that.rejected) &#123; this.onRejectedCallbacks.push(() =&gt; &#123; onRejected(); reject(); &#125;) &#125; &#125;) return promise2;&#125;// 调用const test = new promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试1&#x27;); resolve(); &#125;, 1000)&#125;)test.then(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;);&#125;).then(() =&gt; &#123; console.log(&#x27;这里是调试3&#x27;);&#125;)// 这里是调试4// 这里是调试4// 这里是调试1// 这里是调试2// 这里是调试3 5、接下来，这里又有一个场景，当我们在then(...)方法中有异步任务，我们同样想要让该异步任务阻塞，又该怎么弄呢？按照我们上面的逻辑是阻塞不了then(...)方法中的异步任务的，大家可以尝试一下。 1234567891011121314151617181920const test = new promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试1&#x27;); resolve(); &#125;, 1000)&#125;)test.then(() =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;); &#125;, 2000)&#125;).then(() =&gt; &#123; console.log(&#x27;这里是调试3&#x27;);&#125;)// 输出// 这里是调试4// 这里是调试4// 这里是调试1// 这里是调试3// 这里是调试2 要想阻塞then(...)中的异步任务，这里得分成两种情况来讨论：一种是要阻塞异步任务，需要在then(...)返回一个promise(...)，另一种是不需要阻塞异步任务，那就不需要返回任何值。继续改进代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172promise.prototype.then = function (onFulfilled, onRejected) &#123; // this指向promise(...)对象 const that = this; const promise2 = new promise((resolve, reject) =&gt; &#123; if(that.status === that.fulfilled) &#123; let x = onFulfilled(that.value); if(x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; if(then) &#123; then.call(x, resolve, reject); &#125; else &#123; resolve(x); &#125; &#125; if(that.status === that.pedding) &#123; this.onFulfilledCallbacks.push(() =&gt; &#123; // onFulfilled(...) 为then(...)方法中的回调函数 let x = onFulfilled(that.value); // 执行了then(...)方法中的回调函数并将返回值赋给x // 判断then(...)中回调函数返回值类型 是否为function if(x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; // 如果then存在 说明返回了一个promise if(then) &#123; // 这里采用的方法是将resolve放在返回的promise的then里面执行 . // 这样只有当then(...)方法中的异步事件执行完才resolve(...) 很牛皮 // call(...)绑定this的指向 then.call(x, resolve, reject); &#125; &#125; else &#123; resolve(x); &#125; &#125;) &#125; if(that.status === that.rejected) &#123; this.onRejectedCallbacks.push(() =&gt; &#123; let x = onRejected(that.reason); if(x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; if(then) &#123; then.call(x, resolve, reject); &#125; else &#123; resolve(x); &#125; &#125;) &#125; &#125;) return promise2;&#125;const test = new promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试1&#x27;); resolve(); &#125;, 1000)&#125;)test.then(() =&gt; &#123; // 若要阻塞then(...)中的异步任务需要return一个promise return new promise((resolve1, reject1) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;); resolve1(); &#125;, 2000) &#125;)&#125;).then(() =&gt; &#123; console.log(&#x27;这里是调试3&#x27;);&#125;)// 这里是调试1// 这里是调试2// 这里是调试3 6、到这里，关于promise核心的内容基本已经实现了，再看一下以下案例： 1234567891011new promise(function(resolve)&#123; console.log(&#x27;这里是调试1&#x27;); resolve();&#125;).then(function()&#123; console.log(&#x27;这里是调试2&#x27;);&#125;);console.log(&#x27;这里是调试3&#x27;);// 这里是调试1// 这里是调试2// 这里是调试3 1234567891011new Promise(function(resolve)&#123; console.log(&#x27;这里是调试1&#x27;); resolve();&#125;).then(function()&#123; console.log(&#x27;这里是调试2&#x27;);&#125;);console.log(&#x27;这里是调试3&#x27;);// 这里是调试1// 这里是调试3// 这里是调试2 可以发现，我们的promise和原生的Promise输出结果不一样。根据Promise规范，在.then(...)方法中执行的程序属于微任务（异步任务分为微任务和宏任务，一般的异步事件属于宏任务，微任务比宏任务先执行，但我们自己实现的promise并不支持这个规则，原生的Promise才支持），因此需要将其转化为异步任务，下面我们用setTimeout(...)来模拟实现一下异步任务（原生Promise 并不是用setTimeout(...)实现的） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364promise.prototype.then = function (onFulfilled, onRejected) &#123; const that = this; const promise2 = new promise((resolve, reject) =&gt; &#123; if (that.status === that.fulfilled) &#123; setTimeout(() =&gt; &#123; let x = onFulfilled(that.value); if (x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; if (then) &#123; then.call(x, resolve, reject); &#125; &#125; else &#123; resolve(x); &#125; &#125;) &#125; if (that.status === that.pedding) &#123; that.onFulfilledCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; let x = onFulfilled(that.value); if (x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; if (then) &#123; then.call(x, resolve, reject); &#125; &#125; else &#123; resolve(x); &#125; &#125;) &#125;) that.onRejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; let x = onRejected(that.reason); if (x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; if (then) &#123; then.call(x, resolve, reject); &#125; &#125; else &#123; resolve(x); &#125; &#125;) &#125;) &#125; if (that.status === that.rejected) &#123; setTimeout(() =&gt; &#123; let x = onRejected(that.reason); if (x &amp;&amp; typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;) &#123; let then = x.then; if (then) &#123; then.call(x, resolve, reject); &#125; &#125; else &#123; resolve(x); &#125; &#125;) &#125; &#125;) return promise2;&#125;// 这里是调试1// 这里是调试3// 这里是调试2 7、再来看一个案例： 123456789101112131415161718192021222324const test = new promise((res, rej) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试1&#x27;); res(); &#125;, 4000);&#125;)// 回调函数push进test.onFulfilledCallbacks数组中test.then(() =&gt; &#123; return new promise((res1) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;这里是调试2&#x27;); res1(); &#125;, 3000); &#125;)&#125;)// 回调函数也是push进test.onFulfilledCallbacks数组中，因此两个then(...)是相互独立的，执行顺序按照常规的来处理test.then(() =&gt; &#123; console.log(&#x27;这里是调试3&#x27;);&#125;)// 输出// 这里是调试1// 这里是调试3// 这里是调试2 源码实现参考 宏任务微任务参考 四、async与await async、await相对于promise多了等待的效果； 原理： Promise + 生成器 = async/await; async函数一定会返回一个Promise对象。如果一个async函数的返回值看起来不是promise，那么它将会被隐式得包装在一个promise中； 重要: 使用async与await时，await后面的函数必须返回决议的Promise，不然，程序将停止在await这一步; async、await相对与promise多了等待的效果；具体是怎么实现的？— 使用了yield暂停函数，只有等前面的promise决议之后才执行next(...)，程序才继续往后面执行，表现出来的就是暂停程序的效果； 迭代器 1、一种特殊对象，用于为迭代过程设计的专有接口，简单来说就类似与遍历一个对象； 2、调用返回一个结果对象，对象中有next()方法; 3、next()方法返回一个对象： value: 表示下一个要返回的值；done：没有值可以返回时为true，否则为false; 4、迭代器简易内部实现： 1234567891011121314151617181920function createIterator(items) &#123; let i = 0; return &#123; next: function() &#123; let done = (i &gt;= items.length); // items[i++] 相当于 items[i]; i++; let value = !done ? items[i++] : undefined; return &#123; value: value, done: done // true表示后面没有值了 &#125;; &#125; &#125;;&#125;// 只创建了一个实例 因此iterator一直是同一个let iterator = createIterator([1,2,3]);console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 生成器 1、一个返回迭代器的函数;实现了一种顺序、看似同步的异步流程控制表达风格； 2、关键字yield：表示函数暂停运行; 3、过程：每当执行完一条yield语句后函数就暂停了,直到再次调用函数的next()方法才会继续执行后面的语句; 4、使用yield关键字可以返回任何值或表达式（ 表示要传递给下一个过程的值）; 5、注意点: yield关键字只能在生成器函数的直接内部使用(在生成器函数内部的函数中使用会报错); 不能用箭头函数来创建生成器; 简易使用示例： 1234567891011function *createInterator() &#123; yield 1; yield 2; yield 3;&#125;// 生成器的调用方式与普通函数相同,只不过返回一个迭代器let iterator = createInterator();console.log(iterator.next()); // &#123; value: 1, done: false &#125;console.log(iterator.next()); // &#123; value: 2, done: false &#125;console.log(iterator.next()); // &#123; value: 3, done: false &#125;console.log(iterator.next()); // &#123; value: undefined, done: true &#125; 迭代消息传递： 123456789function *foo(x) &#123; const y = x * (yield); return y;&#125;const it = foo(6);// 启动foo(...)it.next(); const res = it.next(7); // next(...)的数量总是比yield的多一个console.log(res); // 42 首先，传入6作为参数。然后调用it.next(...)，这会启动*foo(...)； 接着，在*foo(...)内部，开始执行语句const y = x ...，但随后就遇到了一个yield表达式。它就会在这一点上暂停*foo(...)（在赋值语句中间），并非在本质上要求调用代码为yield表达式提供一个结果值。接下来，调用it.next(7)，这一句把值7传回作为被暂停的yield表达式结果。 所以，这是赋值语句实际上就是const y = 6 * 7。现在，return y返回值42作为调用it.next(7)的结果。 注意，根据你的视角不同，yield和next(...)调用有一个不匹配。一般来说，需要的next(...)调用要比yield语句多一个，前面的代码片段就有一个yield和两个next(...)调用。 因为第一个next(...)总是用来启动生成器，并运行到第一个yield处。不过，是第二个next(...)调用完成第一个被暂停的yield表达式，第三个next(...)完成第二个yield，以此类推。 消息是双向传递的： yield(...)作为一个表达式，可以发出消息响应next(...)； next(...)也可以向暂停的yield表达式发送值。注意：前面我们说到，第一个next(...)总是用来启动生成器的，此时没有暂停的yield来接受这样一个值，规范和浏览器都会默认丢弃传递给第一个next(...)的任何东西。因此，启动生成器一定要用不带参数的next(...); 123456789function *foo(x) &#123; const y = x * (yield &quot;Hello&quot;); return y;&#125;const it = foo(6);let res = it.next(); // 第一个next()，并不传入任何东西console.log(res.value); // Hellores = it.next(7); // 向等待的yield传入7console.log(res.value); // 42 源码实现&amp;解析 async&amp;await是基于生成器+Promise封装的语法糖，使用async修饰的function实际上会被转化为一个生成器函数，并返回一个决议的Promise(...)，await对应到的是yield，因此await只能在被async修饰的方法中使用 下面看一个例子：这是一个常见的使用async/await的案例 1234567891011121314151617181920212223242526272829303132// 模拟多个异步情况function foo1() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(100); // 如果没有决议(resolve)就不会运行下一个 &#125;, 3000) &#125;)&#125;function foo2() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(200); &#125;, 2500) &#125;)&#125;async function test() &#123; const f1 = await foo1(); const f2 = await foo2(); console.log(&#x27;这里是调试1&#x27;); console.log(f1); console.log(f2); return &#x27;haha&#x27;;&#125;test().then((data) =&gt; &#123; console.log(&#x27;这里是调试2&#x27;); console.log(data);&#125;);// 这里是调试1// 100// 200// 这里是调试2// haha 接着我们来看一下如何将这个案例中的async/await用生成器+Promise来实现： 将test(...)转化为生成器函数： 12345678function *test() &#123; const f1 = yield foo1(); const f2 = yield foo2(); console.log(&#x27;这里是调试1&#x27;); console.log(f1); console.log(f2); return &#x27;haha&#x27;;&#125; 实现方法run(...)，用于调用生成器*test(...)： 12345678910111213141516171819202122232425262728293031323334353637function run(generatorFunc) &#123; return function() &#123; const gen = generatorFunc(); // async 默认返回Promise return new Promise((resolve, reject) =&gt; &#123; function step(key, arg) &#123; let generatorResult; try &#123; // 相当于执行gen.next(...) generatorResult = gen[key](arg); &#125; catch (error) &#123; return reject(error); &#125; // gen.next() 得到的结果是一个 &#123; value, done &#125; 的结构 const &#123; value, done &#125; = generatorResult; if (done) &#123; return resolve(value); &#125; else &#123; return Promise.resolve(value).then(val =&gt; step(&#x27;next&#x27;, val), err =&gt; step(&#x27;throw&#x27;, err)); &#125; &#125; step(&quot;next&quot;); &#125;) &#125;&#125;const haha = run(test);haha().then((data) =&gt; &#123; console.log(&#x27;这里是调试2&#x27;); console.log(data);&#125;);// 这里是调试1// 100// 200// 这里是调试2// haha async/await 参考","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/tags/JavaScript/"}]},{"title":"Array.forEach源码解读","slug":"Array.forEach源码解读","date":"2020-06-01T09:56:29.000Z","updated":"2023-05-18T14:27:34.592Z","comments":true,"path":"2020/06/01/Array.forEach源码解读/","link":"","permalink":"http://yonsunzhen.github.io/2020/06/01/Array.forEach%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"源码实现 123456789101112131415161718192021222324252627282930313233function myForEach(arr, callback) &#123; let T, k; if(arr === null) &#123; throw new TypeError(&#x27;this is null or not defined&#x27;); &#125; // 用于处理若传入的arr为非数组的情况(string等) const O = Object(arr); // 无符号右移：将十进制转化为二进制 右移 const len = O.length &gt;&gt;&gt; 0; if(typeof callback !== &#x27;function&#x27;) &#123; throw new TypeError(`$&#123;callback&#125; is not a function`); &#125; if(arguments.length &gt; 1) &#123; T = callback; &#125; k = 0; while (k &lt; len) &#123; // 如果指定的属性在指定的对象或其原型链中，则in运算符返回true // 用于过滤未初始化的值 if(k in O) &#123; const kValue = O[k]; // kValue, k, O 对应着forEach回调函数3个参数, 数组当前项的值 数组当前项的索引 数组对象本身 // call：将callbak的this指向其自己的内部 callback.call(T, kValue, k, O); &#125; k++; &#125; return undefined;&#125;const test = [1,2,,3];myForEach(test, (item) =&gt; &#123; console.log(item); // 1 2 3&#125;) 技能点 1、无符号右移：将对应数转化为二进制，接着向右移位得到的数值。 12const oldValue = 64; // 等于二进制的100000const newValue = oldValue &gt;&gt;&gt; 5; // 等于二进制的10, 即十进制的2 2、使用技巧：转化数据（数值不变，其他的类型全部转化为0） 12341 &gt;&gt;&gt; 0 // 1undefined &gt;&gt;&gt; 0 // 0null &gt;&gt;&gt; 0 // 0string&#x27; &gt;&gt;&gt; 0 // 0 注意事项 1、async await的语法糖不起作用：由于其内部封装并调用了回调函数，因此就算用了async await也不起作用。 2、无法随时退出循环：不能使用break/continue的方式退出或中断循环，因为其内部使用while循环。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"js之深度优先遍历与广度优先遍历","slug":"js之深度优先遍历与广度优先遍历","date":"2020-03-24T02:46:04.000Z","updated":"2023-05-18T13:33:50.812Z","comments":true,"path":"2020/03/24/js之深度优先遍历与广度优先遍历/","link":"","permalink":"http://yonsunzhen.github.io/2020/03/24/js%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E4%B8%8E%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/","excerpt":"","text":"什么是深度优先和广度优先 1、概念：深度优先是自上而下的遍历搜索，广度优先则是逐层遍历。比如，现有如下树结构： graph TD; 1((1))-->2-1 1((1))-->2-2 1((1))-->2-3 2-1((2-1))-->3-1((3-1)) 2-1((2-1))-->3-2((3-2)) 2-2((2-2))-->3-3((3-3)) 2-3((2-3))-->3-4((3-4)) 深度遍历优先的遍历顺序为： graph LR; 1((1))-->2-1 2-1((2-1))-->3-1((3-1)) 3-1((3-1))-->3-2((3-2)) 3-2((3-2))-->2-2((2-2)) 2-2((2-2))-->3-3((3-3)) 3-3((3-3))-->2-3((2-3)) 2-3((2-3))-->3-4((3-4)) 广度遍历优先的遍历顺序为： graph LR; 1((1))-->2-1 2-1((2-1))-->2-2((2-2)) 2-2((2-2))-->2-3((2-3)) 2-3((2-3))-->3-1((3-1)) 3-1((3-1))-->3-2((3-2)) 3-2((3-2))-->3-3((3-3)) 3-3((3-3))-->3-4((3-4)) 代码实现 1、现有如下树结构数据 123456789101112131415161718192021222324const tree = &#123; data: &#123; no: 1 &#125;, children: [ &#123; data: &#123; no: 2 .1 &#125;, children: [ &#123; data: &#123; no: 3.1 &#125;, children: [] &#125;, &#123; data: &#123; no: 3.2 &#125;, children: [] &#125; ] &#125;, &#123; data: &#123; no: 2.2 &#125;, children: [ &#123; data: &#123; no: 3.3 &#125;, children: [] &#125; ] &#125;, &#123; data: &#123; no: 2.3 &#125;, children: [ &#123; data: &#123; no: 3.4 &#125;, children: [] &#125; ] &#125;, ]&#125; 深度优先遍历 采用递归遍历的方式 123456789101112function breadthFirst (data) &#123; let result = []; result.push(data.data.no); function recursion (data) &#123; data.forEach(item =&gt; &#123; result.push(item.data.no); item.children &amp;&amp; recursion(item.children); &#125;) &#125; recursion(data.children); return result.join(&#x27;,&#x27;);&#125; 广度优先遍历 采用队列的方式 先进先出 123456789101112131415function depthFirst (data) &#123; let result = []; let queue = data; result.push(queue.data.no); while (queue.children.length &gt; 0) &#123; // first为数组queue.children的第一个值 const first = queue.children[0]; result.push(first.data.no); // 将第一个值的所有子节点push到数组queue.children的末尾 以达到一层一层遍历的效果 first.children &amp;&amp; (queue.children.push(...first.children)); // 将数组queue.children的第一个值删除(已遍历) queue.children.shift(); &#125; return result.join(&#x27;,&#x27;);&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yonsunzhen.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"基于centos7.5.1804安装mysql-8.0.19","slug":"基于centos7.5.1804安装mysql-8.0.19","date":"2020-03-18T02:41:00.000Z","updated":"2023-05-18T13:33:50.813Z","comments":true,"path":"2020/03/18/基于centos7.5.1804安装mysql-8.0.19/","link":"","permalink":"http://yonsunzhen.github.io/2020/03/18/%E5%9F%BA%E4%BA%8Ecentos7.5.1804%E5%AE%89%E8%A3%85mysql-8.0.19/","excerpt":"","text":"详细过程 1、MySql官网下载安装包。点击下载 2、上传安装包到云服务器指定文件夹并解压，我们这里将安装目录指定为 /usr/local/mysql8 3、在mysql8根目录下新建文件夹data，用于存放数据 4、创建 mysql 用户组和 mysql 用户 12groupadd mysqluseradd -g mysql mysql 5、改变mysql8目录权限 1chown -R mysql.mysql /usr/local/mysql8/ 6、初始化数据库 创建mysql_install_db安装文件 12mkdir mysql_install_dbchmod 777 ./mysql_install_db 初始化，在mysql8目录下执行以下命令 1234bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql8 --datadir=/usr/local/mysql8/data/usr/local/mysql8/bin/mysqld (mysqld 8.0.11) initializing of server in progress as process 5826[Server] A temporary password is generated for root@localhost: twi=Tlsi&lt;0O!/usr/local/mysql/bin/mysqld (mysqld 8.0.11) initializing of server has completed 记录自己的临时密码 twi=Tlsi&lt;0O! 以上执行如果报错 bin/mysqld: error while loading shared libraries: libnuma.so.1: 是因为缺少numactl 安装一下即可 1yum -y install numactl 7、配置mysql 1cp /usr/local/mysql8/support-files/mysql.server /etc/init.d/mysqld 修改my.cnf文件 1vim /etc/my.cnf 如下面所示： 123456789101112[mysqld]# skip-grant-tables 表示首次使用mysql时跳过密码验证 当自己忘记记录临时密码时可用# skip-grant-tables basedir = /usr/local/mysql8 datadir = /usr/local/mysql8 socket = /usr/local/mysql8/mysql.sock character-set-server=utf8 port = 3306 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[client] socket = /usr/local/mysql8/mysql.sock default-character-set=utf8 8、建立MySql服务，在mysql8根目录下执行以下命令 1cp -a ./support-files/mysql.server /etc/init.d/mysqld 添加到系统服务 1chkconfig --add mysql 检查服务是否生效 1chkconfig --list mysqld 9、配置全局环境变量 1 vi /etc/profile 在 profile 文件底部添加如下两行配置，保存后退出 1export PATH=$PATH:/usr/local/mysql8/bin:/usr/local/mysql8/lib 设置环境变量立即生效 1 source /etc/profile 10、启动MySQL服务 1service mysql start 11、登录MySQL，执行以下命令后输入刚才那个临时密码 1mysql -u root -p 12、操作数据库前必须将临时密码设置为别的。 报错信息为 You must reset your password using ALTER USER statement before executing this statement MySQL版本5.7.6版本开始的用户可以使用如下命令：详情见 1mysql&gt; ALTER USER USER() IDENTIFIED BY &#x27;your password&#x27;; 问题集锦 1、MySQL官网下载太慢的解决方法：详情见 2、Navicat远程连接云服务器上的MySQL失败（1251 client does not support authentication protocol requested by server;consider upgrading Mysql client ERROR 1396 (HY000): Operation ALTER USER failed for ‘root’@‘localhost’）：详情见 1ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;root&#x27;; MySql8配置 1、mysql -u root -p 输入密码 2、初次使用修改密码命令：ALTER USER USER() IDENTIFIED BY 'Xiaoming250'; 3、show databases； 显示所有数据库 4、quit; 退出mysql命令行编辑","categories":[{"name":"后端","slug":"后端","permalink":"http://yonsunzhen.github.io/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[]},{"title":"call、apply和bind详解","slug":"call、apply和bind详解","date":"2019-12-03T12:46:55.000Z","updated":"2023-05-18T14:27:34.596Z","comments":true,"path":"2019/12/03/call、apply和bind详解/","link":"","permalink":"http://yonsunzhen.github.io/2019/12/03/call%E3%80%81apply%E5%92%8Cbind%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"call和apply call 1、用法：foo.call(obj, arg1, arg2, ...) -&gt; 主要用于改变this的指向； 123456789function foo(year, place) &#123; console.log(this.name+&quot; is &quot;+year+&quot; born from &quot;+place);&#125;window.name = &#x27;syz&#x27;;const obj = &#123; name: &#x27;syc&#x27;&#125;foo(1995, &#x27;china&#x27;); // syz is 1995 born from chinafoo.call(obj, 1995, &#x27;china&#x27;); // syc is 1995 born from china 首先我们要知道，每个函数中的this是在调用时绑定的，this指向哪里，完全取决于函数的调用位置。比如上面，我们先执行了foo() ，基于我们调用这个函数的位置,如果我们在浏览器中运行的话（一般都是），此时this指向的是window，所以这时候this.name = syz; 那如果我们想要让 this.a = obj.name 的话，就可以使用call来显式绑定this的指向。 apply 1、用法：obj.apply(thisObj, [arg1, arg2, ...]) -&gt; 主要用于改变this的指向； 123456789function foo(year, place) &#123; console.log(this.name+&quot; is &quot;+year+&quot; born from &quot;+place);&#125;window.name = &#x27;syz&#x27;;const obj = &#123; name: &#x27;syc&#x27;&#125;foo(1995, &#x27;china&#x27;); // syz is 1995 born from chinafoo.apply(obj, [1995, &#x27;china&#x27;]); // syc is 1995 born from china apply方法和call方法的区别就是apply中第二个参数接受的是一个数组。当函数的参数数量不明确时就可以使用apply来改变this的指向，有点类似扩展运算符...的效果。 call和apply的作用 1、一个重要的作用就是扩充函数赖以运行的作用域； 1234567891011window.color = &quot;red&quot;；let o = &#123; color: &quot;blue&quot;&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); //redsayColor.call(this); //red 因为在全局环境下调用函数 this默认指向windowsayColor.call(window); //red this指向windowsayColor.call(o); //blue this指向o对象 使用call和apply来扩充作用域的最大好处，就是对象不需要和方法有任何耦合关系，调用者控制this的指向，就可以实现不同的功能。 bind 1、用法：foo.bind(obj, arg1, arg2, ...) -&gt; 返回一个函数，该函数永久地改变this的指向； 12345678910function foo(year, place) &#123; console.log(this.name+&quot; is &quot;+year+&quot; born from &quot;+place);&#125;window.name = &#x27;syz&#x27;;const obj = &#123; name: &#x27;syc&#x27;&#125;foo(1995, &#x27;china&#x27;); // syz is 1995 born from chinalet haha = foo.bind(obj, 1995, &#x27;china&#x27;); haha(); // syc is 1995 born from china bind类似于call，但是call和apply会立即执行，而bind是返回绑定this之后的函数(永久地改变this的指向，原函数不变)。 apply、call、bind三者的区别 三者都可以改变函数的this的指向； 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window。 三者都可以传参，但是call和bind是参数列表，apply是数组。 bind是返回绑定this之后的函数，便于稍后调用；apply和call则是立即执行。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"isNaN()与Number.isNaN()的使用","slug":"isNaN()与Number.isNaN()的使用","date":"2019-11-07T04:13:37.000Z","updated":"2023-05-18T14:27:34.596Z","comments":true,"path":"2019/11/07/isNaN()与Number.isNaN()的使用/","link":"","permalink":"http://yonsunzhen.github.io/2019/11/07/isNaN()%E4%B8%8ENumber.isNaN()%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"","text":"目的 1、后台验证参数。 2、如果传进来的参数是非数值字符串，类似“haha”，“Hello World”这种就不通过。 3、如果传进来的值为NaN报不通过。 4、 如果传进来的值为’true’报不通过。 5、方法：isNaN(param) 为true表示不通过。 isNaN() 流程：（非number型为true，因为会先进行类型转换） isNaN()在接受到一个值之后，会尝试将这个值转换为数值，例如字符串‘10’或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。–《你不知道的JavaScript》 Number.isNaN() 内部实现：（非numberxing为false，因为直接检测是否为number型） typeof n === 'number' &amp;&amp; isNaN(n) 总结&amp;&amp;区别 1、isNaN()为false的话，Number.isNaN()一定是false。 2、isNaN()为true的话，Number.isNaN()不一定为true，例如检测字符串的情况。 3、Number.isNaN()：前提一定得是number，不然肯定为false。 4、例如：对于所有的字符串都一样 Number.isNaN(‘bbbb’) // false isNaN(‘bbbb’) // true NaN字面意思是非法数值（但还是属于数值型）。 首先，NaN是一个number类型。 typeof NaN === “number” // true Number('true') // NaN Number(true) // 1 NaN: 任何数值除以非数值都为NaN。 typeof 2/'abc' // NaN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"算法基础之二分查找","slug":"算法基础之二分查找","date":"2019-10-10T08:11:13.000Z","updated":"2023-05-18T13:33:50.813Z","comments":true,"path":"2019/10/10/算法基础之二分查找/","link":"","permalink":"http://yonsunzhen.github.io/2019/10/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"场景 当待搜索的集合是相对静态的有序数据集时，此时使用二分查找是最好的选择。 复杂度 0(lgn), n为要查找的元素个数。 思路过程 通过变量left和right控制一个循环来查找元素(其中left和right是正在查找的数据集的两个边界值)。 首先,将left和right分别设置为0和length-1.在循环的每次迭代过程中,将middle设置为left和right之间区域的中间值。 如果处于middle的元素比目标值小,将左索引值(left)移动到middle后一个元素的位置上,即下一组要搜索的区域为当前数据的下半区。 如果处于middle的元素比目标值大,将右索引值(right)移动到middle前一个元素的位置上,即下一组要搜索的区域为当前数据的上半区。 直到left和right重合即可停止搜索。 12345678910111213141516171819202122/** * @param arr 要搜索的数组集 * @param target 搜索的值 * @return 若存在就返回该值在数组中的下标,若不存在就返回-1 */function binarySearch(arr, target) &#123; let length = arr.length; let left = 0; let right = length - 1; while(left &lt;= right) &#123; let middleIndex = Math.floor((right + left) / 2); let middle = arr[middleIndex]; if(target &gt; middle) &#123; left = middleIndex + 1; &#125; else if(target &lt; middle) &#123; right = middleIndex - 1; &#125; else&#123; return middleIndex; &#125; &#125; return -1;&#125; 关键点 由于要搜索的数组集长度是奇数还是偶数是不确定的,因此采用Math.floor方法进行处理(返回小于等于某个数的最大整数)。","categories":[{"name":"算法","slug":"算法","permalink":"http://yonsunzhen.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"JavaScript模块化：CommonJS、ES6 Module","slug":"JavaScript模块化：CommonJS、ES6 Module","date":"2019-09-29T07:55:23.000Z","updated":"2023-05-18T14:27:34.594Z","comments":true,"path":"2019/09/29/JavaScript模块化：CommonJS、ES6 Module/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/29/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%EF%BC%9ACommonJS%E3%80%81ES6%20Module/","excerpt":"","text":"CommonJS 前言 NodeJS中使用的模块规范。 根据CommonJS规范，一个单独的文件就是一个模块（module）。加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 CommonJS采用同步加载模块的方式，只有加载完才能执行后面的操作，主要适用于服务端。 使用规则 1、exports与require使用的模块导入导出规则遵循的是CommonJS(AMD和CMD)规范, 一般在NodeJS(express,koa)中使用，是相对比较先出现的规范,也是目前大多数浏览器支持的模块导入导出规范。 module.exports 与 exports 1、一个文件即为一个module； 2、一个module中有很多字段，例如 id path parent exports等等，可以直接在js文件输出module即可查看； 3、exports表示这个module要导出的数据，module.export默认指向一个空的对象内存； 4、变量exports默认指向module.exports（引用传递）； 5、module实际上导出的数据是在module.export这个变量中； require 1、使用require即可导入另一模块中导出的数据； exports与require之间的联系 无论模块exports的是什么数据类型，module.exports与require指向的是同一块内存地址，任何一方改变都会影响另一方的数据（动态） 案例一： 123456789101112131415161718192021222324252627282930313233343536373839404142// a.js文件let aNum = 1;let aArr = [1];setTimeout(() =&gt; &#123; aNum = 11; // 并不会影响module.exports.aNum的值 aArr.push(11); // 会影响module.exports.aArr的值 console.log(&#x27;1s a模块改变数据aNum&amp;aArr:&#x27;); console.log(`aNum=$&#123;aNum&#125;,module.exports.aNum=$&#123;module.exports.aNum&#125;`); console.log(`aArr=$&#123;aArr&#125;,module.exports.aArr=$&#123;module.exports.aArr&#125;`);&#125;, 1000)setTimeout(() =&gt; &#123; console.log(`3s a模块接受数据:aNum=$&#123;module.exports.aNum&#125;,aArr=$&#123;module.exports.aArr&#125;`);&#125;, 3000)// 以下写法等价于// module.exports.aNum = aNum aNum属于基本类型 值拷贝// module.exports.aArr = aArr aArr属于对象 值引用module.exports = &#123; aNum, aArr&#125;;console.log(`a模块已导出数据:aNum=$&#123;module.exports.aNum&#125;,aArr=$&#123;module.exports.aArr&#125;`);// b.js文件const a = require(&quot;./commonjs_a&quot;);console.log(`b模块已接收数据:aNum=$&#123;a.aNum&#125;,aArr=$&#123;a.aArr&#125;`);setTimeout(() =&gt; &#123; console.log(`2s b模块接受数据:aNum=$&#123;a.aNum&#125;,aArr=$&#123;a.aArr&#125;`); a.aNum = 2; a.aArr = [2] console.log(`2s b模块改变数据:aNum=$&#123;a.aNum&#125;,aArr=$&#123;a.aArr&#125;`);&#125;, 2000)// 输出结果a模块已导出数据:aNum=1,aArr=1b模块已接收数据:aNum=1,aArr=11s a模块改变数据aNum&amp;aArr:aNum=11,module.exports.aNum=1aArr=1,11,module.exports.aArr=1,112s b模块接受数据:aNum=1,aArr=1,112s b模块改变数据:aNum=2,aArr=23s a模块接受数据:aNum=2,aArr=2 ES6 Module 前言 使用规则 1、export与import是ES组织官方退出的模块化方案,一般在typescript和三大框架(Angular, Vue, React)中比较常见,但目前支持这套规范的客户端浏览器比较少,所以通常情况下代码都要经过Babel转换成目前浏览器能支持的,也就是exports和require那一套。 export 与 export default 1、无论导出数据是什么类型的，export导出的都是变量的引用绑定； 2、任何未显式导出的变量、函数或类都是模块私有的，无法从模块外部访问； 123456789101112131415161718192021222324252627// es6_a.mjsexport let aNum = 1;export let aArr = [1];setTimeout(() =&gt; &#123; aNum = 11; aArr.push(11); console.log(&#x27;1s a模块改变数据aNum&amp;aArr:&#x27;); console.log(`aNum=$&#123;aNum&#125;,`); console.log(`aArr=$&#123;aArr&#125;,`);&#125;, 1000)console.log(`a模块已导出数据:aNum=$&#123;aNum&#125;,aArr=$&#123;aArr&#125;`);// es6_b.mjs// import时必须加&#123; &#125;import &#123;aNum, aArr&#125; from &#x27;./es6_a.mjs&#x27;;console.log(`b模块已接收数据:aNum=$&#123;aNum&#125;,aArr=$&#123;aArr&#125;`);setTimeout(() =&gt; &#123; console.log(`2s b模块接受数据:aNum=$&#123;aNum&#125;,aArr=$&#123;aArr&#125;`);&#125;, 2000);// 输出结果a模块已导出数据:aNum=1,aArr=1b模块已接收数据:aNum=1,aArr=11s a模块改变数据aNum&amp;aArr:aNum=11aArr=1,112s b模块接受数据:aNum=11,aArr=1,11 2、export default有点特殊，导出的数据要根据数据类型来定，与CommonJS的module.exports有点类似 12345678910111213141516171819202122232425262728293031// es6_a.mjslet aNum = 1;let aArr = [1];setTimeout(() =&gt; &#123; aNum = 11; aArr.push(11); console.log(&#x27;1s a模块改变数据aNum&amp;aArr:&#x27;); console.log(`aNum=$&#123;aNum&#125;`); console.log(`aArr=$&#123;aArr&#125;`);&#125;, 1000)// 与module.exports类似export default &#123; aNum, // 数值类型 深拷贝 aArr // 对象类型 浅拷贝&#125;console.log(`a模块已导出数据:aNum=$&#123;aNum&#125;,aArr=$&#123;aArr&#125;`);// es6_b.mjsimport a from &#x27;./es6_a.mjs&#x27;;console.log(`b模块已接收数据:aNum=$&#123;a.aNum&#125;,aArr=$&#123;a.aArr&#125;`);setTimeout(() =&gt; &#123; console.log(`2s b模块接受数据:aNum=$&#123;a.aNum&#125;,aArr=$&#123;a.aArr&#125;`);&#125;, 2000);// 输出结果a模块已导出数据:aNum=1,aArr=1b模块已接收数据:aNum=1,aArr=11s a模块改变数据aNum&amp;aArr:aNum=11aArr=1,112s b模块接受数据:aNum=1,aArr=1,11 3、* 在export * from 'xxx'后面加注释会报怪异的bug，导出的数据为undefined import 1、导入default的不需要使用&#123; &#125;，导入非默认模块则需要加&#123; &#125; 2、一个文件可以同时导出默认的模块和非默认的模块，如下所示： 123456789101112131415// es6_a.mjsexport let color = &#x27;red&#x27;;export default function(num1, num2) &#123; return num1 + num2;&#125;// es6_b.mjs// 默认值必须排在非默认值之前import sum, &#123; color &#125; from &#x27;./es6_a.mjs&#x27;;console.log(sum(1,2));console.log(color);// 输出结果3red 3、可以使用as在导出和导入时重命名 123456789101112// es6_a.mjsfunction sum(num1, num2) &#123; return num1 + num2;&#125;export &#123; sum as a &#125;;// es6_b.mjsimport &#123; a as aa &#125; from &#x27;./es6_a.mjs&#x27;;console.log(aa(1,2));// 输出结果3 两者差异 1. CommonJS 模块输出的是一个值的拷贝（根据数据类型分为深拷贝或浅拷贝），ES6 模块输出的是值的引用（任何数据类型） CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。ES6 模块的运行机制与 CommonJS 不一样。JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 的import有点像 Unix 系统的“符号连接”，原始值变了，import加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 2. CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 3. ES6 Module中导入的数据为const，不允许重新赋值；而CommonJS中导入的数据允许重新赋值 参考1","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"koa服务端获取不到客户端请求的origin","slug":"koa服务端获取不到客户端请求的origin","date":"2019-09-27T03:41:56.000Z","updated":"2023-05-18T13:33:50.813Z","comments":true,"path":"2019/09/27/koa服务端获取不到客户端请求的origin/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/27/koa%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%8E%B7%E5%8F%96%E4%B8%8D%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%B7%E6%B1%82%E7%9A%84origin/","excerpt":"","text":"问题 用koa2作为服务端，在解决跨域问题时需要获取客户端请求的origin字段前端使用ajax访问服务端接口,客户端请求的request中origin为null 12345678910111213141516module.exports = async function (ctx, next) &#123; const origin = URL.parse(ctx.get(&#x27;origin&#x27;) || ctx.get(&#x27;referer&#x27;) || &#x27;&#x27;); if (origin.protocol &amp;&amp; origin.host) &#123; ctx.set(&#x27;Access-Control-Allow-Origin&#x27;, `$&#123;origin.protocol&#125;//$&#123;origin.host&#125;`); ctx.set(&#x27;Access-Control-Allow-Methods&#x27;, &#x27;POST, GET, OPTIONS, DELETE, PUT&#x27;); ctx.set(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;X-Requested-With, User-Agent, Referer, Content-Type, Cache-Control,accesstoken&#x27;); ctx.set(&#x27;Access-Control-Max-Age&#x27;, &#x27;86400&#x27;); ctx.set(&#x27;Access-Control-Allow-Credentials&#x27;, &#x27;true&#x27;); &#125; if (ctx.method !== &#x27;OPTIONS&#x27;) &#123; await next(); &#125; else &#123; ctx.body = &#x27;&#x27;; ctx.status = 204; &#125;&#125; 原因 客户端请求服务端接口是在本地电脑环境(非服务器环境),然而origin字段记录的是我发起http请求的域名URL,由于我是在本地进行访问的,肯定也就不存在域名URL了。 解决 全局安装http-server (搭建服务器环境) 1npm install http-server -g 在当前文件目录下启动服务器 123456D:\\uidq2225\\Desktop\\test&gt;http-serverStarting up http-server, serving ./Available on: http://10.219.125.46:8080 http://127.0.0.1:8080Hit CTRL-C to stop the server 浏览器访问 http://10.219.125.46:8080/index 重新发起请求即可","categories":[{"name":"BUG","slug":"BUG","permalink":"http://yonsunzhen.github.io/categories/BUG/"}],"tags":[]},{"title":"3、无重复字符的最长子串","slug":"3、无重复字符的最长子串","date":"2019-09-12T07:38:16.000Z","updated":"2023-05-18T13:33:50.800Z","comments":true,"path":"2019/09/12/3、无重复字符的最长子串/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/12/3%E3%80%81%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","excerpt":"","text":"题目: 给定一个字符串,请你找出其中不含有重复字符的最长子串的长度 思路:","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/tags/leetcode/"}]},{"title":"2、两数之和","slug":"2、两数之和","date":"2019-09-12T07:21:55.000Z","updated":"2023-05-18T13:33:50.800Z","comments":true,"path":"2019/09/12/2、两数之和/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/12/2%E3%80%81%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"","text":"题目: 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/tags/leetcode/"}]}],"categories":[{"name":"其他","slug":"其他","permalink":"http://yonsunzhen.github.io/categories/%E5%85%B6%E4%BB%96/"},{"name":"Angular","slug":"Angular","permalink":"http://yonsunzhen.github.io/categories/Angular/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yonsunzhen.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"后端","slug":"后端","permalink":"http://yonsunzhen.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"BUG","slug":"BUG","permalink":"http://yonsunzhen.github.io/categories/BUG/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/categories/leetcode/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/tags/JavaScript/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/tags/leetcode/"}]}