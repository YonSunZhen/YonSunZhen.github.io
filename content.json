{"meta":{"title":"码上就来","subtitle":null,"description":null,"author":"皮皮虾","url":"http://yonsunzhen.github.io","root":"/"},"pages":[],"posts":[{"title":"基于centos7.5.1804安装mysql-8.0.19","slug":"基于centos7.5.1804安装mysql-8.0.19","date":"2020-03-18T02:41:00.000Z","updated":"2020-03-18T13:23:13.963Z","comments":true,"path":"2020/03/18/基于centos7.5.1804安装mysql-8.0.19/","link":"","permalink":"http://yonsunzhen.github.io/2020/03/18/基于centos7.5.1804安装mysql-8.0.19/","excerpt":"","text":"详细过程 1、MySql官网下载安装包。点击下载 2、上传安装包到云服务器指定文件夹并解压，我们这里将安装目录指定为 /usr/local/mysql8 3、在mysql8根目录下新建文件夹data，用于存放数据 4、创建 mysql 用户组和 mysql 用户 12groupadd mysqluseradd -g mysql mysql 5、改变mysql8目录权限 1chown -R mysql.mysql /usr/local/mysql8/ 6、初始化数据库 创建mysql_install_db安装文件 12mkdir mysql_install_dbchmod 777 ./mysql_install_db 初始化，在mysql8目录下执行以下命令 1234bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql8 --datadir=/usr/local/mysql8/data/usr/local/mysql8/bin/mysqld (mysqld 8.0.11) initializing of server in progress as process 5826[Server] A temporary password is generated for root@localhost: twi=Tlsi&lt;0O!/usr/local/mysql/bin/mysqld (mysqld 8.0.11) initializing of server has completed 记录自己的临时密码 twi=Tlsi&lt;0O! 以上执行如果报错 bin/mysqld: error while loading shared libraries: libnuma.so.1: 是因为缺少numactl 安装一下即可 1yum -y install numactl 7、配置mysql 1cp /usr/local/mysql8/support-files/mysql.server /etc/init.d/mysqld 修改my.cnf文件 1vim /etc/my.cnf 如下面所示： 123456789101112[mysqld]# skip-grant-tables 表示首次使用mysql时跳过密码验证 当自己忘记记录临时密码时可用# skip-grant-tables basedir = /usr/local/mysql8 datadir = /usr/local/mysql8 socket = /usr/local/mysql8/mysql.sock character-set-server=utf8 port = 3306 sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[client] socket = /usr/local/mysql8/mysql.sock default-character-set=utf8 8、建立MySql服务，在mysql8根目录下执行以下命令 1cp -a ./support-files/mysql.server /etc/init.d/mysqld 添加到系统服务 1chkconfig --add mysql 检查服务是否生效 1chkconfig --list mysqld 9、配置全局环境变量 1 vi /etc/profile 在 profile 文件底部添加如下两行配置，保存后退出 1export PATH=$PATH:/usr/local/mysql8/bin:/usr/local/mysql8/lib 设置环境变量立即生效 1 source /etc/profile 10、启动MySQL服务 1service mysql start 11、登录MySQL，执行以下命令后输入刚才那个临时密码 1mysql -u root -p 12、操作数据库前必须将临时密码设置为别的。 报错信息为You must reset your password using ALTER USER statement before executing this statement MySQL版本5.7.6版本开始的用户可以使用如下命令：详情见 1mysql&gt; ALTER USER USER() IDENTIFIED BY &apos;your password&apos;; 问题集锦 1、MySQL官网下载太慢的解决方法：详情见 2、Navicat远程连接云服务器上的MySQL失败（1251 client does not support authentication protocol requested by server;consider upgrading Mysql client ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'）：详情见 1ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;root&apos;; MySql8配置 1、mysql -u root -p 输入密码 2、初次使用修改密码命令：ALTER USER USER() IDENTIFIED BY 'Xiaoming250'; 3、show databases； 显示所有数据库 4、quit; 退出mysql命令行编辑","categories":[{"name":"后端","slug":"后端","permalink":"http://yonsunzhen.github.io/categories/后端/"}],"tags":[]},{"title":"call、apply和bind详解","slug":"call、apply和bind详解","date":"2019-12-03T12:46:55.000Z","updated":"2020-03-18T12:25:10.493Z","comments":true,"path":"2019/12/03/call、apply和bind详解/","link":"","permalink":"http://yonsunzhen.github.io/2019/12/03/call、apply和bind详解/","excerpt":"","text":"call和apply call 1、用法：foo.call(obj, arg1, arg2, ...) -&gt; 主要用于改变this的指向； 123456789function foo(year, place) &#123; console.log(this.name+\" is \"+year+\" born from \"+place);&#125;window.name = 'syz';const obj = &#123; name: 'syc'&#125;foo(1995, 'china'); // syz is 1995 born from chinafoo.call(obj, 1995, 'china'); // syc is 1995 born from china 首先我们要知道，每个函数中的this是在调用时绑定的，this指向哪里，完全取决于函数的调用位置。比如上面，我们先执行了foo() ，基于我们调用这个函数的位置,如果我们在浏览器中运行的话（一般都是），此时this指向的是window，所以这时候this.name = syz; 那如果我们想要让 this.a = obj.name 的话，就可以使用call来显式绑定this的指向。 apply 1、用法：obj.apply(thisObj, [arg1, arg2, ...]) -&gt; 主要用于改变this的指向； 123456789function foo(year, place) &#123; console.log(this.name+\" is \"+year+\" born from \"+place);&#125;window.name = 'syz';const obj = &#123; name: 'syc'&#125;foo(1995, 'china'); // syz is 1995 born from chinafoo.apply(obj, [1995, 'china']); // syc is 1995 born from china apply方法和call方法的区别就是apply中第二个参数接受的是一个数组。 call和apply的作用 1、一个重要的作用就是扩充函数赖以运行的作用域； 1234567891011window.color = \"red\"；let o = &#123; color: \"blue\"&#125;;function sayColor() &#123; console.log(this.color);&#125;sayColor(); //redsayColor.call(this); //red 因为在全局环境下调用函数 this默认指向windowsayColor.call(window); //red this指向windowsayColor.call(o); //blue this指向o对象 使用call和apply来扩充作用域的最大好处，就是对象不需要和方法有任何耦合关系，调用者控制this的指向，就可以实现不同的功能。 bind 1、用法：foo.bind(obj, arg1, arg2, ...) -&gt; 返回一个函数，该函数永久地改变this的指向； 12345678910function foo(year, place) &#123; console.log(this.name+\" is \"+year+\" born from \"+place);&#125;window.name = 'syz';const obj = &#123; name: 'syc'&#125;foo(1995, 'china'); // syz is 1995 born from chinalet haha = foo.bind(obj, 1995, 'china'); haha(); // syc is 1995 born from china bind类似于call，但是call和apply会立即执行，而bind是返回绑定this之后的函数(永久地改变this的指向，原函数不变)。 apply、call、bind三者的区别 三者都可以改变函数的this的指向； 三者第一个参数都是this要指向的对象，如果没有这个参数或参数为undefined或null，则默认指向全局window。 三者都可以传参，但是call和bind是参数列表，apply是数组。 bind是返回绑定this之后的函数，便于稍后调用；apply和call则是立即执行。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"isNaN()与Number.isNaN()的使用","slug":"isNaN()与Number.isNaN()的使用","date":"2019-11-07T04:13:37.000Z","updated":"2020-03-18T12:25:10.504Z","comments":true,"path":"2019/11/07/isNaN()与Number.isNaN()的使用/","link":"","permalink":"http://yonsunzhen.github.io/2019/11/07/isNaN()与Number.isNaN()的使用/","excerpt":"","text":"目的 1、后台验证参数。 2、如果传进来的参数是非数值字符串，类似“haha”，“Hello World”这种就不通过。 3、如果传进来的值为NaN报不通过。 4、 如果传进来的值为'true'报不通过。 5、方法：isNaN(param) 为true表示不通过。 isNaN() 流程：（非number型为true，因为会先进行类型转换） isNaN()在接受到一个值之后，会尝试将这个值转换为数值，例如字符串‘10’或Boolean值。而任何不能被转换为数值的值都会导致这个函数返回true。--《你不知道的JavaScript》 Number.isNaN() 内部实现：（非numberxing为false，因为直接检测是否为number型） typeof n === 'number' &amp;&amp; isNaN(n) 总结&amp;&amp;区别 1、isNaN()为false的话，Number.isNaN()一定是false。 2、isNaN()为true的话，Number.isNaN()不一定为true，例如检测字符串的情况。 3、Number.isNaN()：前提一定得是number，不然肯定为false。 4、例如：对于所有的字符串都一样 Number.isNaN(‘bbbb’) // false isNaN(‘bbbb’) // true NaN字面意思是非法数值（但还是属于数值型）。 首先，NaN是一个number类型。 typeof NaN === “number” // true Number('true') // NaN Number(true) // 1 NaN: 任何数值除以非数值都为NaN。 typeof 2/'abc' // NaN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"算法基础之二分查找","slug":"算法基础之二分查找","date":"2019-10-10T08:11:13.000Z","updated":"2020-03-18T12:25:10.528Z","comments":true,"path":"2019/10/10/算法基础之二分查找/","link":"","permalink":"http://yonsunzhen.github.io/2019/10/10/算法基础之二分查找/","excerpt":"","text":"场景 当待搜索的集合是相对静态的有序数据集时，此时使用二分查找是最好的选择。 复杂度 0(lgn), n为要查找的元素个数。 思路过程 通过变量left和right控制一个循环来查找元素(其中left和right是正在查找的数据集的两个边界值)。 首先,将left和right分别设置为0和length-1.在循环的每次迭代过程中,将middle设置为left和right之间区域的中间值。 如果处于middle的元素比目标值小,将左索引值(left)移动到middle后一个元素的位置上,即下一组要搜索的区域为当前数据的下半区。 如果处于middle的元素比目标值大,将右索引值(right)移动到middle前一个元素的位置上,即下一组要搜索的区域为当前数据的上半区。 直到left和right重合即可停止搜索。 12345678910111213141516171819202122/** * @param arr 要搜索的数组集 * @param target 搜索的值 * @return 若存在就返回该值在数组中的下标,若不存在就返回-1 */function binarySearch(arr, target) &#123; let length = arr.length; let left = 0; let right = length - 1; while(left &lt;= right) &#123; let middleIndex = Math.floor((right + left) / 2); let middle = arr[middleIndex]; if(target &gt; middle) &#123; left = middleIndex + 1; &#125; else if(target &lt; middle) &#123; right = middleIndex - 1; &#125; else&#123; return middleIndex; &#125; &#125; return -1;&#125; 关键点 由于要搜索的数组集长度是奇数还是偶数是不确定的,因此采用Math.floor方法进行处理(返回小于等于某个数的最大整数)。","categories":[{"name":"算法","slug":"算法","permalink":"http://yonsunzhen.github.io/categories/算法/"}],"tags":[]},{"title":"谈一谈令人混淆的export,import和exports,require","slug":"谈一谈令人混淆的export-import和exports-require","date":"2019-09-29T07:55:23.000Z","updated":"2019-10-11T14:30:09.103Z","comments":true,"path":"2019/09/29/谈一谈令人混淆的export-import和exports-require/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/29/谈一谈令人混淆的export-import和exports-require/","excerpt":"","text":"exports与require exports与require使用的模块导入导出规则遵循的是CommonJS规范, 一般在NodeJS(express,koa)中使用，是相对比较先出现的规范,也是目前大多数浏览器支持的模块导入导出规范。 export与import export与import是后面才出现的一套标准,一般在typescript和三大框架(Angular, Vue, React)中比较常见,但目前支持这套规范的客户端浏览器比较少,所以通常情况下代码都要经过Babel转换成目前浏览器能支持的,也就是exports和require那一套。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yonsunzhen.github.io/categories/JavaScript/"}],"tags":[]},{"title":"koa服务端获取不到客户端请求的origin","slug":"koa服务端获取不到客户端请求的origin","date":"2019-09-27T03:41:56.000Z","updated":"2019-10-11T14:30:09.101Z","comments":true,"path":"2019/09/27/koa服务端获取不到客户端请求的origin/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/27/koa服务端获取不到客户端请求的origin/","excerpt":"","text":"问题 用koa2作为服务端，在解决跨域问题时需要获取客户端请求的origin字段前端使用ajax访问服务端接口,客户端请求的request中origin为null 12345678910111213141516module.exports = async function (ctx, next) &#123; const origin = URL.parse(ctx.get('origin') || ctx.get('referer') || ''); if (origin.protocol &amp;&amp; origin.host) &#123; ctx.set('Access-Control-Allow-Origin', `$&#123;origin.protocol&#125;//$&#123;origin.host&#125;`); ctx.set('Access-Control-Allow-Methods', 'POST, GET, OPTIONS, DELETE, PUT'); ctx.set('Access-Control-Allow-Headers', 'X-Requested-With, User-Agent, Referer, Content-Type, Cache-Control,accesstoken'); ctx.set('Access-Control-Max-Age', '86400'); ctx.set('Access-Control-Allow-Credentials', 'true'); &#125; if (ctx.method !== 'OPTIONS') &#123; await next(); &#125; else &#123; ctx.body = ''; ctx.status = 204; &#125;&#125; 原因 客户端请求服务端接口是在本地电脑环境(非服务器环境),然而origin字段记录的是我发起http请求的域名URL,由于我是在本地进行访问的,肯定也就不存在域名URL了。 解决 全局安装http-server (搭建服务器环境) 1npm install http-server -g 在当前文件目录下启动服务器 123456D:\\uidq2225\\Desktop\\test&gt;http-serverStarting up http-server, serving ./Available on: http://10.219.125.46:8080 http://127.0.0.1:8080Hit CTRL-C to stop the server 浏览器访问 http://10.219.125.46:8080/index 重新发起请求即可","categories":[{"name":"BUG","slug":"BUG","permalink":"http://yonsunzhen.github.io/categories/BUG/"}],"tags":[]},{"title":"3、无重复字符的最长子串","slug":"3、无重复字符的最长子串","date":"2019-09-12T07:38:16.000Z","updated":"2019-09-28T02:30:07.279Z","comments":true,"path":"2019/09/12/3、无重复字符的最长子串/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/12/3、无重复字符的最长子串/","excerpt":"","text":"题目: 给定一个字符串,请你找出其中不含有重复字符的最长子串的长度 思路:","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/tags/leetcode/"}]},{"title":"2、两数之和","slug":"2、两数之和","date":"2019-09-12T07:21:55.000Z","updated":"2020-03-18T12:24:51.200Z","comments":true,"path":"2019/09/12/2、两数之和/","link":"","permalink":"http://yonsunzhen.github.io/2019/09/12/2、两数之和/","excerpt":"","text":"题目: 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。","categories":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/categories/leetcode/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yonsunzhen.github.io/tags/leetcode/"}]}]}